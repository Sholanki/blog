<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Python Compared to JavaScript</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#pros-and-cons">Pros and Cons</a><ol><li><a href="#javascript">JavaScript</a></li><li><a href="#python">Python</a></li></ol></li><li><a href="#getting-help">Getting Help</a></li><li><a href="#comments">Comments</a></li><li><a href="#types">Types</a></li><li><a href="#variables-and-assignment">Variables and Assignment</a></li><li><a href="#more-assignments">More Assignments</a></li><li><a href="#comparison">Comparison</a></li><li><a href="#conditional-logic">Conditional Logic</a></li><li><a href="#iteration">Iteration</a></li><li><a href="#functions">Functions</a></li><li><a href="#classes">Classes</a></li><li><a href="#asynchronous-operations">Asynchronous Operations</a></li><li><a href="#modules">Modules</a></li><li><a href="#boolean-operations">Boolean Operations</a></li><li><a href="#numeric-operations">Numeric Operations</a></li><li><a href="#string-operations">String Operations</a></li><li><a href="#array%2Fsequence-operations">Array/Sequence Operations</a></li><li><a href="#list-comprehensions">List Comprehensions</a></li><li><a href="#function-operations">Function Operations</a></li><li><a href="#error-handling">Error Handling</a></li><li><a href="#json-operations">JSON Operations</a></li><li><a href="#dict%2Fobject%2Fmap-operations">Dict/Object/Map Operations</a></li><li><a href="#set-operations">Set Operations</a></li><li><a href="#regular-expression-operations">Regular Expression Operations</a></li><li><a href="#printing">Printing</a></li><li><a href="#check-for-running-as-main">Check for running as main</a></li><li><a href="#popular-tools%2Flibraries%2Fframeworks">Popular Tools/Libraries/Frameworks</a></li><li><a href="#python-magic-methods">Python Magic Methods</a></li></ol></nav></aside><article><p>This compares the most commonly used features of Python and JavaScript. Lesser used features are omitted.</p><h2 id="overview">Overview</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>standard</td><td><a href="https://docs.python.org/3/" rel="noopener" target="_blank">Python 3 documentation</a></td><td><a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm" rel="noopener" target="_blank">ECMAScript</a></td></tr><tr><td>evaluation</td><td>dynamic</td><td>dynamic</td></tr><tr><td>performance</td><td>slow</td><td>fast</td></tr><tr><td>style guide</td><td><a href="https://www.python.org/dev/peps/pep-0008/" rel="noopener" target="_blank">PEP 8</a>, <a href="https://pypi.org/project/black/" rel="noopener" target="_blank">Black</a></td><td><a href="https://prettier.io/" rel="noopener" target="_blank">Prettier</a></td></tr><tr><td>most common indentation</td><td>4 spaces</td><td>2 spaces</td></tr><tr><td>type coercion</td><td>must be explicit</td><td>implicit</td></tr></tbody></table><p>Once source of performance benchmarks can be found at <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/which-programs-are-fastest.html" rel="noopener" target="_blank">The Computer Language Benchmarks Game</a>.</p><h2 id="pros-and-cons">Pros and Cons</h2><h3 id="javascript">JavaScript</h3><p>pros:</p><ul><li>performance</li><li>ability to run in web browsers (clients) and from command-line (servers)</li><li>great support for asynchronous code</li><li>more compact syntax for functional programming (ex. functools vs. <code>reduce</code>)</li></ul><p>cons:</p><ul><li>still in transition from require to import syntax in Node.js</li><li>type coercions can result in surprising results if not familiar with them</li></ul><h3 id="python">Python</h3><p>pros:</p><ul><li>targeted at scripting and rapid application development</li><li>quantity and maturity of libraries for machine learning</li><li>multiple number types</li><li>some syntax is easier for beginners<ul><li>ex. <code>and</code> vs. <code>&amp;&amp;</code>.</li><li>ex. <code>print</code> vs. <code>console.log</code></li><li>fewer parentheses and no curly braces or semicolons</li></ul></li></ul><p>cons:</p><ul><li>poor performance</li><li>magic methods (a.k.a. &quot;dunder&quot; for double underscore) such as <code>__init__</code> (see list in &quot;Python Magic Methods&quot; section)</li><li>operator overloading (supported by magic methods)</li><li>lots of documentation and examples are still for V2 instead of V3</li><li>anonymous functions are limited to a single expression</li><li>no built-in support for asynchronous code until the asyncio module was added in Python 3.4 (some features require Python 3.7+)</li></ul><h2 id="getting-help">Getting Help</h2><p>In Python, enter the <code>python</code> command to start the REPL and enter <code>help</code>. To get help on a particular library, import it and pass the name to help. For example:</p><pre class="language-python"><code class="language-python"><span class="token keyword">import</span> re<br><span class="token builtin">help</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span></code></pre><p>In JavaScript, perform web searches that begin with &quot;MDN&quot; (for the Mozilla Developer Network) followed by a JavaScript search term. For example, &quot;mdn regexp&quot;.</p><h2 id="comments">Comments</h2><table><thead><tr><th>Type</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>single-line</td><td>//</td><td>#</td></tr><tr><td>multi-line</td><td>/* */</td><td>none</td></tr></tbody></table><h2 id="types">Types</h2><table><thead><tr><th>Type</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>boolean</td><td><code>true</code>, <code>false</code></td><td><code>True</code>, <code>False</code></td></tr><tr><td>number</td><td>default is double precision float; also <code>BigInt</code></td><td><code>int</code>, <code>float</code>, <code>complex</code></td></tr><tr><td>character</td><td>use string type</td><td>use string type</td></tr><tr><td>string</td><td>'text' or &quot;text&quot;</td><td>'text', &quot;text&quot;, '''text''', or &quot;&quot;&quot;text&quot;&quot;&quot;</td></tr><tr><td>string interpolation</td><td>`prefix${expr}suffix`</td><td>f'prefix{expr}suffix'</td></tr><tr><td>array</td><td><code>Array</code>, <code>[v1, v2, ...]</code></td><td>see list, tuple, and range</td></tr><tr><td>list</td><td>see <code>Array</code></td><td><code>[v1, v2, ...]</code>; mutable and homogeneous</td></tr><tr><td>tuple</td><td>no equivalent</td><td><code>(v1, v2, ...)</code>; immutable and heterogeneous</td></tr><tr><td>range</td><td>no equivalent</td><td>range range(start, stop[, step])</td></tr><tr><td>key/value pairs</td><td>Object in the form <code>{k1: v1, k2: v2, ...}</code> and <code>Map</code></td><td>dictionary in the form <code>{'k1': v1, 'k2': v2, ...}</code></td></tr><tr><td>set</td><td><code>new Set()</code></td><td><code>set(v1, v2, ...)</code> or <code>{v1, v2, ...}</code></td></tr><tr><td>function</td><td>see &quot;Function&quot; section below</td><td>see &quot;Function&quot; section below</td></tr><tr><td>class</td><td><code>class Name { ... }</code></td><td><code>class Name:</code></td></tr><tr><td>no value</td><td><code>undefined</code> or <code>null</code></td><td><code>None</code></td></tr></tbody></table><p>In Python, the following values are treated as false when used in a boolean context: False, None, 0, '', and empty sequences.</p><p>In JavaScript, the following values are treated as false when used in a boolean context: false, 0, '', undefined, null.</p><p>Python has sequences whereas JavaScript has arrays. There are three kinds of sequences: list, tuple, and range. A list is a mutable sequence of values that have the same type. A tuple is an immutable sequence of values that have varying types. A range is an immutable sequence of numbers that can be used for looping.</p><p>JavaScript object keys must be strings. Python dict keys can e any immutable type.</p><h2 id="variables-and-assignment">Variables and Assignment</h2><table><thead><tr><th>Topic</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>constant</td><td><code>const NAME = value;</code></td><td><code>NAME = value</code></td></tr><tr><td>variable</td><td><code>let name = value;</code></td><td><code>name = value</code></td></tr></tbody></table><p>Python uses a naming convention (all uppercase) to identify constants, but they can still be modified.</p><h2 id="more-assignments">More Assignments</h2><table><thead><tr><th>Topic</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>spread of array/list</td><td><code>const [v1, v2, ...] = array;</code></td><td><code>v1, v2 = array</code></td></tr><tr><td>spread of object</td><td><code>const {k1, k2, ...} = object;</code></td><td>not supported</td></tr><tr><td>addition</td><td><code>name += expr</code></td><td>same</td></tr><tr><td>subtraction</td><td><code>name -= expr</code></td><td>same</td></tr><tr><td>multiplication</td><td><code>name \*= expr</code></td><td>same</td></tr><tr><td>division</td><td><code>name /= expr</code></td><td>same</td></tr><tr><td>exponentiation</td><td><code>name \*\*= expr</code></td><td>same</td></tr><tr><td>mod (remainder)</td><td><code>name %= expr</code></td><td>same</td></tr><tr><td>logical and</td><td><code>name &amp;&amp;= expr</code></td><td>not supported</td></tr><tr><td>logical or</td><td><code>name \|\|= expr</code></td><td>not supported</td></tr><tr><td>logical xor</td><td><code>name ^= expr</code></td><td>not supported</td></tr><tr><td>bitwise and</td><td><code>name &amp;= expr</code></td><td>same</td></tr><tr><td>bitwise or</td><td><code>name \|= expr</code></td><td>same</td></tr><tr><td>bitwise xor</td><td><code>name ^= expr</code></td><td>same</td></tr><tr><td>signed bit shift</td><td><code>&lt;&lt;=</code> (left), <code>&gt;&gt;=</code> (right)</td><td>same</td></tr><tr><td>unsigned bit shift</td><td><code>&lt;&lt;&lt;=</code> (left), <code>&gt;&gt;&gt;=</code> (right)</td><td>not supported</td></tr></tbody></table><h2 id="comparison">Comparison</h2><table><thead><tr><th>Topic</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>equal for non-objects</td><td><code>==</code> (with coercion) or <code>===</code> (without)</td><td><code>==</code></td></tr><tr><td>equal of objects</td><td><code>===</code></td><td><code>is</code></td></tr><tr><td>not equal of objects</td><td><code>!==</code></td><td><code>is not</code></td></tr><tr><td>not equal</td><td><code>!=</code> (with coercion) or <code>!==</code> (without)</td><td><code>!=</code></td></tr><tr><td>less than</td><td><code>&lt;</code></td><td>same</td></tr><tr><td>less than or equal</td><td><code>&lt;=</code></td><td>same</td></tr><tr><td>greater than</td><td><code>&gt;</code></td><td>same</td></tr><tr><td>greater than or equal</td><td><code>&gt;=</code></td><td>same</td></tr></tbody></table><h2 id="conditional-logic">Conditional Logic</h2><table><thead><tr><th>Topic</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>if</td><td><code>if (cond) stmtOrBlock</code></td><td><code>if cond:</code></td></tr><tr><td>if/else</td><td><code>if (cond) { trueBlock } else { falseBlock}</code></td><td><code>if cond: else:</code></td></tr><tr><td>ternary</td><td><code>cond ? trueValue : falseValue</code></td><td><code>trueValue if cond else falseValue</code></td></tr></tbody></table><h2 id="iteration">Iteration</h2><p>Python &quot;dictionaries&quot; (or dicts) are used to store key/value pairs. In JavaScript this is done with plain objects or the <code>Map</code> class (described later).</p><table><thead><tr><th>Topic</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>classic</td><td><code>for (let var = initial; cond; statements)</code></td><td><code>for var in range(start, stop[, step]):</code></td></tr><tr><td>over collection</td><td><code>for (const value of iterable)</code></td><td><code>for value in sequence:</code></td></tr><tr><td>over object/dict keys</td><td><code>for (const key of Object.keys(obj))</code><br>or <code>for (const key in obj)</code></td><td><code>for key in dict.keys():</code></td></tr><tr><td>over object/dict values</td><td><code>for (const value of Object.values(obj))</code></td><td><code>for value in dict.values():</code></td></tr><tr><td>over object/dict keys and values</td><td><code>for (const [key, value] of Object.entries(obj))</code></td><td><code>for key, value in dict.items():</code></td></tr><tr><td>top-tested</td><td><code>while (cond)</code></td><td><code>while cond:</code></td></tr><tr><td>bottom-tested</td><td><code>do { ... } while (cond);</code></td><td><code>while True: ... if !cond: break</code></td></tr></tbody></table><h2 id="functions">Functions</h2><table><thead><tr><th>Topic</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>named definition</td><td><code>function name(params) { definition }</code></td><td><code>def name(params):</code></td></tr><tr><td>anonymous definition</td><td><code>const name = (params) =&gt; definition</code></td><td><code>lambda params: expression</code></td></tr><tr><td>anonymous single parameter</td><td><code>const name = param =&gt; { ... }</code></td><td>same as above</td></tr><tr><td>anonymous single expression</td><td><code>const name = (params) =&gt; expr</code></td><td>same as above</td></tr><tr><td>variable arguments</td><td><code>function name(p1, p2, ...rest) { ...}</code></td><td><code>def name(p1, p2, \*rest):</code></td></tr><tr><td>return type</td><td>same as Python</td><td>not specified; return a single value<br>that can be an object or array</td></tr><tr><td>calling</td><td><code>name(args)</code></td><td><code>name(args)</code></td></tr></tbody></table><p>Note that unlike JavaScript arrow functions, Python lambdas can only use a single expression, not a block of code.</p><h2 id="classes">Classes</h2><table><thead><tr><th>Topic</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>defining</td><td><code>class Name { ... }</code></td><td><code>class Name:</code></td></tr><tr><td>inheritance</td><td><code>class Sub extends Super { ... }</code></td><td><code>class Sub(Super1, Super2, ...)</code></td></tr><tr><td>constructor</td><td><code>constructor(params) { ... }</code></td><td><code>def \_\_init\_\_(self, params):</code></td></tr><tr><td>instance property declaration</td><td>not declared; set in constructor on <code>this</code></td><td>not declared; set in __init__ on <code>self</code></td></tr><tr><td>instance property reference</td><td><code>this.propName</code></td><td><code>self.propName</code></td></tr><tr><td>class/static property declaration</td><td><code>static propName = value;</code></td><td><code>propName = value;</code></td></tr><tr><td>class/static property reference</td><td><code>CName.propName</code></td><td><code>CName.propName</code> or <code>instance.propName</code></td></tr><tr><td>instance method</td><td><code>name(params) { ... }</code></td><td><code>def name(params):</code></td></tr><tr><td>class/static method declaration</td><td><code>static methodName(params) { ... }</code></td><td><code>@staticmethod</code><br><code>def methodName(params):</code></td></tr><tr><td>class/static method call</td><td><code>CName.methodName(params)</code></td><td><code>CName.methodName(params)</code> or <code>inst.methodName(params)</code></td></tr><tr><td>instantiating</td><td><code>const object = new CName(args);</code></td><td><code>object = CName(args)</code></td></tr></tbody></table><p>JavaScript does not support multiple inheritance, but Python does. In addition to the <code>@staticmethod</code> decorator, Python also supports the <code>@classmethod</code> decorator. The difference is that methods defined with the latter are passed the class as the first argument.</p><h2 id="asynchronous-operations">Asynchronous Operations</h2><p>In Python 3.4+, asynchronous functions are supported by the asyncio library.</p><table><thead><tr><th>Topic</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>async named function</td><td><code>async function name(params) { ... }</code></td><td><code>async def name(params):</code></td></tr><tr><td>async anonymous function</td><td><code>const name = async (params) =&gt; { ... }</code></td><td>not supported</td></tr><tr><td>async call with await</td><td><code>const result = await name(args);</code></td><td><code>result = await name(args)</code></td></tr><tr><td>async call with then</td><td><code>name(args).then(result =&gt; { ... });</code></td><td>n/a</td></tr></tbody></table><p>In JavaScript, async functions return a Promise. Here is an example of running tasks that take a simulated amount of time to complete. The first takes 3 seconds, the second takes 2, and the third takes 1. Each tasks outputs its &quot;starting&quot; message immediately. The &quot;ending&quot; messages appear in reverse order due to their differing sleep durations.</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">sleep</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token parameter">ms</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">doIt</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> sleepMs</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'starting'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">await</span> <span class="token function">sleep</span><span class="token punctuation">(</span>sleepMs<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ending'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> task1 <span class="token operator">=</span> <span class="token function">doIt</span><span class="token punctuation">(</span><span class="token string">'alpha'</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> task2 <span class="token operator">=</span> <span class="token function">doIt</span><span class="token punctuation">(</span><span class="token string">'beta'</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">const</span> task3 <span class="token operator">=</span> <span class="token function">doIt</span><span class="token punctuation">(</span><span class="token string">'gamma'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>task1<span class="token punctuation">,</span> task2<span class="token punctuation">,</span> task3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'finished'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The output is:</p><pre class="language-text"><code class="language-text">starting alpha<br>starting beta<br>starting gamma<br>ending gamma<br>ending beta<br>ending alpha<br>finished</code></pre><p>In Python 3.4, the <code>asyncio</code> library was added. It can be used to create coroutines which are similar to JavaScript Promises. See <a href="https://docs.python.org/3.8/library/asyncio.html" rel="noopener" target="_blank">asyncio docs</a> Python doesn't seem to have to equivalent of the JavaScript Promise methods <code>then</code> and <code>catch</code>.</p><p>Here is an implementation of the previous JavaScript example in Python. It produces the same output.</p><pre class="language-python"><code class="language-python"><span class="token keyword">import</span> asyncio<br><br><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">doIt</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> sleepMs<span class="token punctuation">)</span><span class="token punctuation">:</span><br>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'starting'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><br>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>sleepMs <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span><br>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'ending'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><br><br><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>    task1 <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>doIt<span class="token punctuation">(</span><span class="token string">'alpha'</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    task2 <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>doIt<span class="token punctuation">(</span><span class="token string">'beta'</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    task3 <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>doIt<span class="token punctuation">(</span><span class="token string">'gamma'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>task1<span class="token punctuation">,</span> task2<span class="token punctuation">,</span> task2<span class="token punctuation">)</span><br>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'finished'</span><span class="token punctuation">)</span><br><br>asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="modules">Modules</h2><table><thead><tr><th>Topic</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>defining</td><td>content of file</td><td>content of file</td></tr><tr><td>export</td><td><code>export name = value;</code></td><td>everything is automatically exported</td></tr><tr><td>default export</td><td><code>export default name = value;</code></td><td>not supported</td></tr><tr><td>import default</td><td><code>import name from 'path';</code></td><td>not supported</td></tr><tr><td>import named</td><td><code>import {name1, name2} from 'path';</code></td><td>from moduleName import name1, name2</td></tr><tr><td>import both</td><td><code>import name, {name1, name2} from 'path';</code></td><td>n/a</td></tr><tr><td>where to find</td><td>npm</td><td>pip</td></tr></tbody></table><h2 id="boolean-operations">Boolean Operations</h2><table><thead><tr><th>Operation</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>and</td><td><code>b1 &amp;&amp; b2</code></td><td><code>b1 and b2</code></td></tr><tr><td>or</td><td><code>b1 \|\| b2</code></td><td><code>b1 or b2</code></td></tr><tr><td>not</td><td><code>!b</code></td><td><code>not b</code></td></tr><tr><td>bitwise and</td><td><code>b1 &amp; b2</code></td><td>same</td></tr><tr><td>bitwise or</td><td><code>b1 \| b2</code></td><td>same</td></tr><tr><td>bitwise not</td><td><code>~b</code></td><td>same</td></tr><tr><td>bitwise xor</td><td><code>b1 ^ b2</code></td><td><code>b1 &amp; b2</code></td></tr></tbody></table><h2 id="numeric-operations">Numeric Operations</h2><table><thead><tr><th>Operation</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>basic</td><td><code>+</code>, <code>-</code>, <code>\*</code>, <code>/</code></td><td>same</td></tr><tr><td>exponentiation</td><td><code>*\*</code></td><td>same</td></tr><tr><td>increment</td><td><code>++n1</code> (pre) or <code>n1++</code> (post)</td><td><code>v += 1</code></td></tr><tr><td>decrement</td><td><code>--n1</code> (pre) or <code>n1--</code> (post)</td><td><code>v -= 1</code></td></tr><tr><td>mod (remainder)</td><td><code>%</code></td><td>same</td></tr><tr><td>convert to string</td><td><code>n.toString()</code></td><td><code>str(n)</code></td></tr><tr><td>convert to string with fixed decimals (ex. 2)</td><td><code>n.toFixed(2)</code></td><td><code>&quot;{:.2f}&quot;.format(n)</code></td></tr><tr><td>convert to hex</td><td><code>n.toString(16)</code></td><td><code>hex(n)</code></td></tr><tr><td>convert from hex</td><td><code>parseInt(hexString, 16)</code></td><td><code>int(hexString, 16)</code></td></tr><tr><td>constants</td><td>see Math and Number global objects</td><td>see math module</td></tr><tr><td>functions</td><td>see Math and Number global objects</td><td>see math module</td></tr></tbody></table><h2 id="string-operations">String Operations</h2><table><thead><tr><th>Operation</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>concatenation</td><td><code>s1 + n1</code></td><td><code>s1 + str(n1)</code></td></tr><tr><td>lowercase</td><td><code>s.toLowerCase()</code></td><td><code>s.lower()</code></td></tr><tr><td>uppercase</td><td><code>s.toUpperCase()</code></td><td><code>s.upper()</code></td></tr><tr><td>substring</td><td><code>s1.substring(start[, end])</code></td><td><code>s[start:end]</code> or <code>s[start:]</code> or <code>s[:end]</code></td></tr><tr><td>slice</td><td>like <code>substring</code>, but supports negative indexes</td><td>same as above</td></tr><tr><td>split</td><td><code>s.split(delimiter)</code> returns array</td><td><code>s.split(delimiter)</code> returns list</td></tr><tr><td>starts with</td><td><code>s.startsWith(sub)</code> returns boolean</td><td><code>s.startswith(sub)</code> returns boolean</td></tr><tr><td>ends with</td><td><code>s.endsWith(sub)</code> returns boolean</td><td><code>s.endswith(sub)</code> returns boolean</td></tr><tr><td>contains</td><td><code>s.includes(sub)</code> returns boolean</td><td><code>sub in s</code> returns boolean</td></tr><tr><td>index of</td><td><code>s.indexOf(sub)</code> returns number</td><td><code>s.index(sub[, start[, end]])</code> returns int</td></tr><tr><td>last index of</td><td><code>s.lastIndexOf(sub)</code> returns number</td><td><code>s.rindex(sub[, start[, end]])</code> returns int</td></tr><tr><td>compare</td><td><code>s.localeCompare(sub)</code> returns -1, 0, or 1</td><td>not supported</td></tr><tr><td>replace first</td><td><code>s.replace(oldSub, newSub)</code></td><td><code>s.replace(old, new, 1)</code></td></tr><tr><td>replace all</td><td><code>s.replaceAll(oldSub, newSub)</code></td><td><code>s.replace(old, new)</code></td></tr><tr><td>trim start</td><td><code>s.trimStart()</code></td><td><code>s.lstrip()</code></td></tr><tr><td>trim end</td><td><code>s.trimEnd()</code></td><td><code>s.rstrip()</code></td></tr><tr><td>trim both</td><td><code>s.trim()</code></td><td><code>s.strip()</code></td></tr></tbody></table><h2 id="array%2Fsequence-operations">Array/Sequence Operations</h2><p>Some Python sequence operations apply to all three of kinds of sequences (list, tuple, and range).</p><table><thead><tr><th>Operation</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>is array/sequence</td><td><code>Array.isArray(expression)</code></td><td><code>hasattr(type(obj), '\_\_iter\_\_')</code></td></tr><tr><td>length</td><td><code>arr.length</code></td><td><code>len(seq)</code></td></tr><tr><td>lookup</td><td><code>const value = arr[index];</code></td><td><code>value = seq[index]</code></td></tr><tr><td>subset</td><td><code>const newArr = arr.slice(startIndex[, endIndex]);</code></td><td><code>newSeq = seq[startIndex:endIndex]</code></td></tr><tr><td>concat</td><td><code>const newArr = arr1.concat(arr2, arr3, ...);</code></td><td><code>newSeq = seq1 + seq2</code></td></tr><tr><td>find</td><td><code>const value = arr.find(predicate);</code></td><td><code>next(filter(predicate, iterable))</code></td></tr><tr><td>find index</td><td><code>const index = arr.findIndex(predicate);</code></td><td>see note below this table</td></tr><tr><td>for each</td><td><code>arr.forEach(value =&gt; { ... });</code></td><td><code>for item in seq:</code></td></tr><tr><td>includes</td><td><code>arr.includes(value)</code> returns boolean</td><td><code>value in seq</code></td></tr><tr><td>not includes</td><td><code>!arr.includes(value)</code> returns boolean</td><td><code>value not in seq</code></td></tr><tr><td>index of</td><td><code>const index = arr.indexOf(value[, fromIndex])</code></td><td><code>seq.index(value[, start[, end]])</code></td></tr><tr><td>last index of</td><td><code>const index = arr.lastIndexOf(value[, fromIndex])</code></td><td>not builtin; have to reverse list</td></tr><tr><td>join</td><td><code>arr.join(delimiter)</code> returns string</td><td><code>delimiter.join(iterable)</code></td></tr><tr><td>map</td><td><code>const newArr = arr.map(value =&gt; newValue);</code></td><td><code>iterator = map(function, iterable)</code></td></tr><tr><td>filter</td><td><code>const newArr = arr.filter(predicate);</code></td><td><code>iterator = filter(predicate, iterable)</code></td></tr><tr><td>reduce</td><td><code>const value = arr.reduce((acc, value) =&gt; { ... });</code></td><td><code>from functools import reduce</code><br><code>value = reduce(lambda acc, item: ..., seq, initial)</code></td></tr><tr><td>any/some</td><td><code>arr.some(predicate)</code> returns boolean</td><td><code>any(map(predicate, iterable))</code></td></tr><tr><td>all/every</td><td><code>arr.every(predicate)</code> returns boolean</td><td><code>all(map(predicate, iterable))</code></td></tr><tr><td>add to end</td><td><code>arr.push(value);</code></td><td><code>seq.append(value)</code></td></tr><tr><td>remove from end</td><td><code>const value = arr.pop();</code></td><td><code>seq.pop()</code></td></tr><tr><td>add to start</td><td><code>arr.unshift(value);</code></td><td><code>seq.insert(0, item)</code></td></tr><tr><td>remove from start</td><td><code>const value = arr.shift();</code></td><td><code>del seq[0]</code></td></tr><tr><td>remove all</td><td><code>arr = [];</code></td><td><code>seq.clear()</code></td></tr><tr><td>sort</td><td><code>arr.sort(comparator);</code></td><td><code>list.sort(key=fn)</code> where <code>fn</code> returns a value for the key</td></tr><tr><td>change</td><td><code>arr.splice(start, delCount, v1, v2, ...);</code></td><td>combine <code>del</code> and <code>insert</code> above</td></tr></tbody></table><p>In the Python list <code>sort</code> method, &quot;vef&quot; is short for value extract function.</p><p>JavaScript generators can be used to implement lazy evaluations. The Python <code>filter</code> and <code>map</code> functions are lazy. To get values from them, pass the result to a function like <code>list</code> or <code>set</code>. For example:</p><pre class="language-python"><code class="language-python">numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><br>doubled <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> n<span class="token punctuation">:</span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> numbers<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>The string <code>join</code> method takes an iterable over strings. To join non-string values, use <code>map</code>. For example:</p><pre class="language-python"><code class="language-python"><span class="token string">'-'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">,</span> numberList<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Python doesn't have a simple, builtin way to find the first item in a list that matches some criteria. This naive approach is probably the most efficient.</p><pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span>aList<span class="token punctuation">,</span> predicate<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  <span class="token keyword">for</span> index <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>aList<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>      <span class="token keyword">if</span> predicate<span class="token punctuation">(</span>aList<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>          <span class="token keyword">return</span> index<br>  <span class="token keyword">return</span> <span class="token boolean">None</span></code></pre><h2 id="list-comprehensions">List Comprehensions</h2><p>Python supports list comprehensions, but JavaScript does not. Here are some examples. TODO: Add these!</p><h2 id="function-operations">Function Operations</h2><table><thead><tr><th>Operation</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>name</td><td><code>fn.name</code></td><td><code>fn.__name__</code></td></tr><tr><td>required parameter count</td><td><code>fn.length</code></td><td><code>from inspect import getfullargspec</code><br><code>len(getfullargspec(fn).args)</code></td></tr><tr><td>get implementation code</td><td><code>fn.toString()</code></td><td><code>from inspect import getsource</code><br><code>getsource(fn)</code></td></tr><tr><td>bind</td><td><code>const newFn = fn.bind(thisArg, arg1, arg2, ...)</code></td><td><code>from functools import partial</code><br><code>newFn = partial(fn, arg1, arg2, ...)</code></td></tr><tr><td>call</td><td><code>fn.call(thisArg, arg1, arg2, ...)</code></td><td><code>method(obj, arg1, arg2, ...)</code></td></tr><tr><td>apply</td><td><code>fn.apply(thisArg, argArray)</code></td><td><code>method(obj, *argList)</code></td></tr></tbody></table><p>The Python <code>partial</code> function cannot be used on methods, only functions.</p><h2 id="error-handling">Error Handling</h2><p>Python refers to errors as exceptions.</p><table><thead><tr><th>Operation</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>throw error</td><td><code>throw new Error(message);</code></td><td><code>raise ExClass(args)</code></td></tr><tr><td>catch error</td><td><code>try { ... } catch (e) { ... } finally { ... }</code></td><td><code>try: ... except ExClass: ...</code></td></tr></tbody></table><h2 id="json-operations">JSON Operations</h2><table><thead><tr><th>Operation</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>create</td><td><code>const jsonString = JSON.stringify(expr);</code></td><td><code>jsonString = json.dumps(expr)</code></td></tr><tr><td>parse</td><td><code>const value = JSON.parse(jsonString);</code></td><td><code>value = json.loads(jsonString)</code></td></tr></tbody></table><p>In Python, you must <code>import json</code>. There are many builtin Python exception classes. The base class of all of them is Error.</p><h2 id="dict%2Fobject%2Fmap-operations">Dict/Object/Map Operations</h2><p>To store associations between keys and values, Python uses &quot;dictionaries&quot;.</p><table><thead><tr><th>Operation</th><th>Python</th></tr></thead><tbody><tr><td>create</td><td><code>dict = {}</code></td></tr><tr><td>get length</td><td><code>len(dict)</code></td></tr><tr><td>set value of key</td><td><code>dict[key] = value</code></td></tr><tr><td>get value of key</td><td><code>dict[key]</code> or <code>dict.get(key)</code></td></tr><tr><td>get all keys</td><td><code>dict.keys()</code> or <code>list(dict)</code></td></tr><tr><td>get all values</td><td><code>dict.values()</code></td></tr><tr><td>get all keys and values</td><td><code>dict.items()</code></td></tr><tr><td>test if key present</td><td><code>key in dict</code></td></tr><tr><td>delete key</td><td><code>del dict[key]</code></td></tr><tr><td>delete all keys</td><td><code>dict.clear()</code></td></tr><tr><td>iterate over</td><td><code>for item in dict.items():</code></td></tr></tbody></table><p>JavaScript uses plain objects or instances of the <code>Map</code> class to store associations between keys and values. The keys in JavaScript objects must be must be strings, integers, or symbols, but keys in <code>Map</code> instances can be any type.</p><table><thead><tr><th>Operation</th><th>JavaScript Object</th><th>JavaScript Map</th></tr></thead><tbody><tr><td>create</td><td><code>const obj = {};</code></td><td><code>const map = new Map();</code></td></tr><tr><td>get length</td><td><code>Object.keys(obj).length</code></td><td><code>map.size</code></td></tr><tr><td>set value of key</td><td><code>obj.key = value</code> or <code>obj[key] = value</code></td><td><code>map.set(key, value)</code></td></tr><tr><td>get value of key</td><td><code>obj.key</code> or <code>obj[key]</code></td><td><code>map.get(key)</code></td></tr><tr><td>get all keys</td><td><code>Object.keys(obj)</code></td><td><code>map.keys()</code></td></tr><tr><td>get all values</td><td><code>Object.values(obj)</code></td><td><code>map.values()</code></td></tr><tr><td>get all keys and values</td><td><code>Object.entries(obj)</code></td><td><code>map.entries()</code></td></tr><tr><td>test if key present</td><td><code>key in obj</code> or <code>obj.hasOwnProperty(key)</code></td><td><code>map.has(key)</code></td></tr><tr><td>delete key</td><td><code>delete obj.key</code> or <code>delete obj[key]</code></td><td><code>map.delete(key)</code></td></tr><tr><td>delete all keys</td><td><code>obj = {}</code></td><td><code>map.clear()</code></td></tr><tr><td>iterate over</td><td><code>for (const prop in obj)</code></td><td><code>map.forEach((value, key) =&gt; { ... });</code></td></tr></tbody></table><h2 id="set-operations">Set Operations</h2><table><thead><tr><th>Operation</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>create</td><td><code>const s = new Set();</code></td><td><code>s = {values}</code> or <code>s = set(values)</code></td></tr><tr><td>length</td><td><code>s.size</code></td><td><code>len(s)</code></td></tr><tr><td>includes</td><td><code>s.has(value)</code></td><td><code>value in s</code></td></tr><tr><td>add</td><td><code>s.add(value)</code></td><td>same</td></tr><tr><td>remove</td><td><code>s.delete(value);</code></td><td><code>s.remove(value)</code></td></tr><tr><td>remove all</td><td><code>s.clear()</code></td><td>same</td></tr><tr><td>iterate over</td><td><code>s.forEach(value =&gt; { ... });</code></td><td><code>for value in set:</code></td></tr><tr><td>convert to list/array</td><td><code>a = s.values();</code></td><td><code>l = list(s)</code></td></tr></tbody></table><h2 id="regular-expression-operations">Regular Expression Operations</h2><p>In Python, import the <code>re</code> library. It supports the following methods:</p><ul><li>split: Split a string by the occurrences of a pattern.</li></ul><table><thead><tr><th>Operation</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>create</td><td><code>const re = /pattern/flags</code> or<br><code>const re = new RegExp(pattern, flags)</code></td><td><code>import re</code><br><code>regex = re.compile(pattern)</code></td></tr><tr><td>test if a string matches</td><td><code>if (re.test(str))</code></td><td><code>if regex.search(str):</code></td></tr><tr><td>get first match</td><td><code>str.match(re)</code></td><td><code>regex.search(str)</code></td></tr><tr><td>get all matches</td><td><code>str.matchAll(re)</code> or <code>re.exec(str)</code></td><td><code>regex.finditer(str)</code></td></tr><tr><td>split string on re</td><td><code>str.split(re)</code></td><td><code>regex.split(str)</code></td></tr></tbody></table><h2 id="printing">Printing</h2><table><thead><tr><th>Operation</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>print values</td><td><code>console.log(v1, v2, ...);</code></td><td><code>print(v1, v2, ..)</code></td></tr><tr><td>print error</td><td><code>console.error(message);</code></td><td><code>import sys</code><br>print(v1, v2, ..., file=sys.stderr)</td></tr></tbody></table><h2 id="check-for-running-as-main">Check for running as main</h2><p>In Python, use <code>if __name__ == '__main__':</code>. In Node.js, use <code>if (require.main === module) {</code>.</p><h2 id="popular-tools%2Flibraries%2Fframeworks">Popular Tools/Libraries/Frameworks</h2><table><thead><tr><th>Topic</th><th>JavaScript</th><th>Python</th></tr></thead><tbody><tr><td>command-line</td><td>Node.js</td><td><code>python</code> interpreter</td></tr><tr><td>utilities</td><td>Lodash, Ramda</td><td>pydash</td></tr><tr><td>web server</td><td>Express</td><td>Flask</td></tr><tr><td>web framework</td><td>React, Vue, Svelte</td><td>Flask</td></tr><tr><td>dates and times</td><td>date.fns, Moment.js, Temporal</td><td>datetime (in standard library)</td></tr><tr><td>unit tests</td><td>Jest, Mocha, Chai, @testing-library</td><td>unittest (in standard library), nose2, pytest</td></tr><tr><td>end-to-end tests</td><td>Cypress</td><td></td></tr><tr><td>math</td><td>mathjs</td><td>math (in standard library)</td></tr></tbody></table><h2 id="python-magic-methods">Python Magic Methods</h2><p>Python magic methods support operator overloading for custom classes. This is a partial list of the magic methods that a Python class can be implement.</p><table><thead><tr><th>Method</th><th>Parameters</th><th>Purpose</th></tr></thead><tbody><tr><td>object lifecycle</td><td></td><td></td></tr><tr><td><code>__new__</code></td><td>cls, ...</td><td>creates a new object</td></tr><tr><td><code>__init__</code></td><td>self, ...</td><td>initializes a new object</td></tr><tr><td><code>__del__</code></td><td>self</td><td>destroys an object</td></tr><tr><td>string representation</td><td></td><td></td></tr><tr><td><code>__repr__</code></td><td>self</td><td>returns a string representations useful to developers</td></tr><tr><td><code>__str__</code></td><td>self</td><td>returns a string representation useful to users</td></tr><tr><td>comparisons</td><td></td><td></td></tr><tr><td><code>__cmp__</code></td><td>self, other</td><td>removed in Python 3</td></tr><tr><td><code>__ne__</code></td><td>self, other</td><td>determines if this object is not equal to another</td></tr><tr><td><code>__eq__</code></td><td>self, other</td><td>determines if this object is equal to another</td></tr><tr><td><code>__lt__</code></td><td>self, other</td><td>determines if this object is &lt; another</td></tr><tr><td><code>__le__</code></td><td>self, other</td><td>determines if this object is &lt;= to another</td></tr><tr><td><code>__gt__</code></td><td>self, other</td><td>determines if this object is &gt; another</td></tr><tr><td><code>__ge__</code></td><td>self, other</td><td>determines if this object is &gt;= to another</td></tr><tr><td>also see functools.total_ordering()</td><td></td><td></td></tr><tr><td>list-like operations</td><td></td><td></td></tr><tr><td><code>__getitem__</code></td><td>self, key</td><td>gets an item from a list by index</td></tr><tr><td><code>__setitem__</code></td><td>self, key, value</td><td>sets an item in a list by index</td></tr><tr><td><code>__delitem__</code></td><td>self, key</td><td>deletes an item from a list by index</td></tr><tr><td><code>__iter__</code></td><td>self</td><td>returns an iterator</td></tr><tr><td><code>__contains__</code></td><td>self, item</td><td>determines if a given item is contained</td></tr><tr><td>dict operations</td><td></td><td></td></tr><tr><td><code>__missing__</code></td><td>self, key</td><td>returns value to use when key is not present</td></tr><tr><td>math operations</td><td></td><td></td></tr><tr><td><code>__add__</code></td><td>self, other</td><td>adds an object to another</td></tr><tr><td><code>__sub__</code></td><td>self, other</td><td>subtracts an object from another</td></tr><tr><td><code>__mul__</code></td><td>self, other</td><td>multiplies an object by another</td></tr><tr><td><code>__div__</code></td><td>self, other</td><td>divides an object by another</td></tr><tr><td><code>__mod__</code></td><td>self, other</td><td>mods an object by another</td></tr><tr><td>pickling (serialization)</td><td></td><td></td></tr><tr><td><code>__getstate__</code></td><td>self</td><td>pickles an object</td></tr><tr><td><code>__setstate__</code></td><td>self</td><td>unpickles an object</td></tr><tr><td>other</td><td></td><td></td></tr><tr><td><code>__call__</code></td><td>self, ...</td><td>treats an object as a function; can change state</td></tr></tbody></table></article>