<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Python Compared to JavaScript</h2><p>This compares the most commonly used features of Python and JavaScript.<br>Lesser used features are omitted.</p><h2>Overview</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>standard</td><td><a href="https://docs.python.org/3/">https://docs.python.org/3/</a></td><td>ECMAScript</td></tr><tr><td>evaluation</td><td>dynamic</td><td>dynamic</td></tr><tr><td>performance</td><td>slow</td><td>fast</td></tr><tr><td>style guide</td><td><a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a>, Black</td><td>Prettier</td></tr><tr><td>most common indentation</td><td>4 spaces</td><td>2 spaces</td></tr><tr><td>type coercion</td><td>must be explicit</td><td>implicit</td></tr></tbody></table><p>Once source of performance benchmarks can be found at<br><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/which-programs-are-fastest.html">https://benchmarksgame-team.pages.debian.net/benchmarksgame/which-programs-are-fastest.html</a>.</p><h2>Comments</h2><table><thead><tr><th>Type</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>single-line</td><td>#</td><td>//</td></tr><tr><td>multi-line</td><td>none</td><td>/* */</td></tr></tbody></table><h2>Types</h2><table><thead><tr><th>Type</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>boolean</td><td>True, False</td><td>true, false</td></tr><tr><td>number</td><td>int, float, complex</td><td>default is dbl precision float; also BigInt</td></tr><tr><td>character</td><td>use string type</td><td>use string type</td></tr><tr><td>string</td><td>'text', &quot;text&quot;, '''text''', or &quot;&quot;&quot;text&quot;&quot;&quot;</td><td>'text' or &quot;text&quot;</td></tr><tr><td>string interpolation</td><td>f'prefix{expr}suffix'</td><td>`prefix${expr}suffix`</td></tr><tr><td>array</td><td>see list, tuple, and range</td><td>[v1, v2, ...]</td></tr><tr><td>list</td><td>[v1, v2, ...]</td><td>see array</td></tr><tr><td>tuple</td><td>(v1, v2, ...)</td><td>no equivalent</td></tr><tr><td>range</td><td>range range(start, stop[, step])</td><td>no equivalent</td></tr><tr><td>object / dict</td><td>{'k1': v1, 'k2': v2, ...}</td><td>{k1: v1, k2: v2, ...}</td></tr><tr><td>function</td><td>see &quot;Function&quot; section below</td><td>see &quot;Function&quot; section below</td></tr><tr><td>class</td><td>class Name:</td><td>class Name { ... }</td></tr><tr><td>regular expression</td><td>re.compile(pattern)</td><td>/pattern/flags or new RegExp(pattern)</td></tr><tr><td>no value</td><td>None</td><td>undefined or null</td></tr></tbody></table><p>In Python, the following values are treated as false when used<br>in a boolean context: False, None, 0, '', and empty sequences.<br>In JavaScript, the following values are treated as false when used<br>in a boolean context: false, 0, '', undefined, null.</p><p>Python has sequences instead of arrays.<br>There are three kinds of sequences: list, tuple, and range.<br>A list is a mutable sequence of values that have the same type.<br>A tuple is an immutable sequence of values that have varying types.<br>A range is an immutable sequence of numbers that can be used for looping.</p><p>JS object keys must be strings.<br>Python dict keys can e any immutable type.</p><h2>Variables and Assignment</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>constant</td><td>NAME = value</td><td>const NAME = value;</td></tr><tr><td>variable</td><td>name = value</td><td>let name = value;</td></tr></tbody></table><p>Python uses a naming convention (all uppercase) to identify constants,<br>but they can still be modified.</p><h2>More Assignments</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>spread of array/list</td><td>v1, v2 = array</td><td>const [v1, v2, ...] = array;</td></tr><tr><td>spread of object</td><td>not supported</td><td>const {k1, k2, ...} = object;</td></tr><tr><td>addition</td><td>name += expr</td><td>same</td></tr><tr><td>subtraction</td><td>name -= expr</td><td>same</td></tr><tr><td>multiplication</td><td>name *= expr</td><td>same</td></tr><tr><td>division</td><td>name /= expr</td><td>same</td></tr><tr><td>exponentiation</td><td>name **= expr</td><td>same</td></tr><tr><td>mod (remainder)</td><td>name %= expr</td><td>same</td></tr><tr><td>logical and</td><td>not supported</td><td>name &amp;&amp;= expr</td></tr><tr><td>logical or</td><td>not supported</td><td>name ||= expr</td></tr><tr><td>logical xor</td><td>not supported</td><td>name ^= expr</td></tr><tr><td>bitwise and</td><td>name &amp;= expr</td><td>same</td></tr><tr><td>bitwise or</td><td>name |= expr</td><td>same</td></tr><tr><td>bitwise xor</td><td>name ^= expr</td><td>same</td></tr><tr><td>signed bit shift</td><td>&lt;&lt;= (left), &gt;&gt;= (right)</td><td>same</td></tr><tr><td>unsigned bit shift</td><td>not supported</td><td>&lt;&lt;&lt;= (left), &gt;&gt;&gt;= (right)</td></tr></tbody></table><h2>Comparison</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>equal for non-objects</td><td>==</td><td>== (with coercion) or === (without)</td></tr><tr><td>equal of objects</td><td>is</td><td>===</td></tr><tr><td>not equal of objects</td><td>is not</td><td>!==</td></tr><tr><td>not equal</td><td>!=</td><td>!= (with coercion) or !== (without)</td></tr><tr><td>less than</td><td>&lt;</td><td>same</td></tr><tr><td>less than or equal</td><td>&lt;=</td><td>same</td></tr><tr><td>greater than</td><td>&gt;</td><td>same</td></tr><tr><td>greater than or equal</td><td>&gt;=</td><td>same</td></tr></tbody></table><h2>Conditional Logic</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>if</td><td>if cond:</td><td>if (cond) stmtOrBlock</td></tr><tr><td>if/else</td><td>if cond: else:</td><td>if (cond) { trueBlock } else { falseBlock}</td></tr><tr><td>ternary</td><td>trueValue if cond else falseValue</td><td>cond ? trueValue : falseValue</td></tr></tbody></table><h2>Iteration</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>classic</td><td>for var in range(start, stop[, step]):</td><td>for (let var = initial; cond; statements)</td></tr><tr><td>over collection</td><td>for value in sequence:</td><td>for (const value of iterable)</td></tr><tr><td>over object/dict keys</td><td>for key in dict.keys():</td><td>for (const key of Object.keys(obj))</td></tr><tr><td>over object/dict values</td><td>for value in dict.values():</td><td>for (const value of Object.values(obj))</td></tr><tr><td>over object/dict keys and values</td><td>for key, value in dict.items():</td><td>for (const [key, value] of Object.entries(obj))</td></tr><tr><td>top-tested</td><td>while cond:</td><td>while (cond)</td></tr><tr><td>bottom-tested</td><td>while True: ... if !cond: break</td><td>do { ... } while (cond);</td></tr></tbody></table><h2>Functions</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>named definition</td><td>def name(params):</td><td>function name(params) { definition }</td></tr><tr><td>anonymous definition</td><td>lambda params: expression</td><td>const name = (params) =&gt; definition</td></tr><tr><td>anonymous single parameter</td><td>same as above</td><td>const name = param =&gt; { ... }</td></tr><tr><td>anonymous single expression</td><td>same as above</td><td>const name = (params) =&gt; expr</td></tr><tr><td>variable arguments</td><td>def name(p1, p2, *rest):</td><td>function name(p1, p2, ...rest) { ...}</td></tr><tr><td>return type</td><td>not specified; return a single value<br>that can be an object or array</td><td>same as Python</td></tr><tr><td>calling</td><td>name(args)</td><td>name(args)</td></tr></tbody></table><p>Note that unlike JS arrow functions, Python lambdas<br>can only use a single expression, not a block of code.</p><h2>Classes</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>defining</td><td>class Name:</td><td>class Name { ... }</td></tr><tr><td>inheritance</td><td>class Sub(Super1, Super2, ...)</td><td>class Sub extends Super { ... }</td></tr><tr><td>constructor</td><td>def __init__(self, params):</td><td>constructor(params) { ... }</td></tr><tr><td>instance property declaration</td><td>not declared; set in __init__ on self</td><td>not declared; set in constructor on this</td></tr><tr><td>instance property reference</td><td>self.propName</td><td>this.propName</td></tr><tr><td>class/static property declaration</td><td>propName = value;</td><td>static propName = value;</td></tr><tr><td>class/static property reference</td><td>CName.proName or instance.propName</td><td>CName.propName</td></tr><tr><td>instance method</td><td>def name(params):</td><td>name(params) { ... }</td></tr><tr><td>class/static method declaration</td><td>@staticmethod<br>def methodName(params):</td><td>static methodName(params) { ... }</td></tr><tr><td>class/static method call</td><td>CName.methodName(params) or inst.methodName(params)</td><td>CName.methodName(params)</td></tr><tr><td>instantiating</td><td>object = CName(args)</td><td>const object = new CName(args);</td></tr></tbody></table><p>JS does not support multiple inheritance, but Python does.<br>In addition to the <code>@staticmethod</code> decorator, Python also supports the<br><code>@classmethod</code> decorator. The difference is that methods defined with<br>the latter are passed the class as the first argument.</p><h2>Asynchronous Operations</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>async named function</td><td>async def name(params):</td><td>async function name(params) { ... }</td></tr><tr><td>async anonymous function</td><td>not supported</td><td>const name = async (params) =&gt; { ... }</td></tr><tr><td>async call with await</td><td>result = await name(args)</td><td>const result = await name(args);</td></tr><tr><td>async call with then</td><td>n/a</td><td>name(args).then(result =&gt; { ... });</td></tr></tbody></table><p>In JS, async functions return a Promise.<br>In Python, async function return a coroutine which is similar.<br>Python doesn't seem to have to equivalent of<br>the JS Promise methods <code>then</code> and <code>catch</code>.</p><h2>Modules</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>defining</td><td>content of file</td><td>content of file</td></tr><tr><td>export</td><td>everything is automatically exported</td><td>export name = value;</td></tr><tr><td>default export</td><td>not supported</td><td>export default name = value;</td></tr><tr><td>import default</td><td>not supported</td><td>import name from 'path';</td></tr><tr><td>import named</td><td>from moduleName import name1, name2</td><td>import {name1, name2} from 'path';</td></tr><tr><td>import both</td><td>n/a</td><td>import name, {name1, name2} from 'path';</td></tr><tr><td>where to find</td><td>pip</td><td>npm</td></tr></tbody></table><h2>Boolean Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>and</td><td>b1 and b2</td><td>b1 &amp;&amp; b2</td></tr><tr><td>or</td><td>b1 or b2</td><td>b1 || b2</td></tr><tr><td>not</td><td>not b</td><td>!b</td></tr><tr><td>bitwise and</td><td>b1 &amp; b2</td><td>b1 &amp; b2</td></tr><tr><td>bitwise or</td><td>b1 | b2</td><td>b1 | b2</td></tr><tr><td>bitwise not</td><td>~b</td><td>~b</td></tr><tr><td>bitwise xor</td><td>b1 &amp; b2</td><td>b1 ^ b2</td></tr></tbody></table><h2>Numeric Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>basic</td><td>+, -, *, /</td><td>+, -, *, /</td></tr><tr><td>exponentiation</td><td>**</td><td>**</td></tr><tr><td>increment</td><td>v += 1</td><td>++n1 (pre) or n1++ (post)</td></tr><tr><td>decrement</td><td>v -= 1</td><td>--n1 (pre) or n1-- (post)</td></tr><tr><td>mod (remainder)</td><td>%</td><td>%</td></tr><tr><td>convert to string</td><td>str(n)</td><td>n.toString()</td></tr><tr><td>convert to string with fixed decimals</td><td>&quot;{:.2f}&quot;.format(n)</td><td>n.toFixed(decimals)</td></tr><tr><td>convert to hex</td><td>hex(n)</td><td>n.toString(16)</td></tr><tr><td>convert from hex</td><td>int(hexString, 16)</td><td>parseInt(hexString, 16)</td></tr><tr><td>constants</td><td>see math module</td><td>see Math and Number global objects</td></tr><tr><td>functions</td><td>see math module</td><td>see Math and Number global objects</td></tr></tbody></table><h2>String Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>concatenation</td><td>s1 + str(n1)</td><td>s1 + n1</td></tr><tr><td>lowercase</td><td>s.lower()</td><td>s.toLowerCase()</td></tr><tr><td>uppercase</td><td>s.upper()</td><td>s.toUpperCase()</td></tr><tr><td>substring</td><td>s[start:end] or s[start:] or s[:end]</td><td>s1.substring(start[, end])</td></tr><tr><td>slice</td><td>same as above</td><td>like substring, but supports negative indexes</td></tr><tr><td>split</td><td>s.split(delimiter) returns list</td><td>s.split(delimiter) returns array</td></tr><tr><td>starts with</td><td>s.startswith(sub)</td><td>s.startsWith(sub) returns boolean</td></tr><tr><td>ends with</td><td>s.endswith(sub)</td><td>s.endsWith(sub) returns boolean</td></tr><tr><td>contains</td><td>sub in s</td><td>s.includes(sub) returns boolean</td></tr><tr><td>index of</td><td>s.index(sub[, start[, end]])</td><td>s.indexOf(sub) returns number</td></tr><tr><td>last index of</td><td>s.rindex(sub[, start[, end]])</td><td>s.lastIndexOf(sub) returns number</td></tr><tr><td>compare</td><td>not supported</td><td>s.localeCompare(sub) returns -1, 0, or 1</td></tr><tr><td>replace first</td><td>s.replace(old, new, 1)</td><td>s.replace(oldSub, newSub)</td></tr><tr><td>replace all</td><td>s.replace(old, new)</td><td>s.replaceAll(oldSub, newSub)</td></tr><tr><td>trim start</td><td>s.lstrip()</td><td>s.trimStart()</td></tr><tr><td>trim end</td><td>s.rstrip()</td><td>s.trimEnd()</td></tr><tr><td>trim both</td><td>s.strip()</td><td>s.trim()</td></tr></tbody></table><h2>Array/Sequence Operations</h2><p>Some Python sequence operations apply to all three of kinds of sequences<br>(list, tuple, and range).</p><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>is array/sequence</td><td>hasattr(type(obj), '__iter__')</td><td>Array.isArray(expression)</td></tr><tr><td>length</td><td>len(seq)</td><td>arr.length</td></tr><tr><td>lookup</td><td>value = seq[index]</td><td>const value = arr[index];</td></tr><tr><td>subset</td><td>newSeq = seq[startIndex:endIndex]</td><td>const newArr = arr.slice(startIndex[, endIndex]);</td></tr><tr><td>concat</td><td>newSeq = seq1 + seq2</td><td>const newArr = arr1.concat(arr2, arr3, ...);</td></tr><tr><td>find</td><td>next(filter(predicate, iterable))</td><td>const value = arr.find(predicate);</td></tr><tr><td>find index</td><td>see note below this table</td><td>const index = arr.findIndex(predicate);</td></tr><tr><td>for each</td><td>for item in seq:</td><td>arr.forEach(value =&gt; { ... });</td></tr><tr><td>includes</td><td>value in seq</td><td>arr.includes(value) returns boolean</td></tr><tr><td>not includes</td><td>value not in seq</td><td>!arr.includes(value) returns boolean</td></tr><tr><td>index of</td><td>seq.index(value[, start[, end]])</td><td>const index = arr.indexOf(value[, fromIndex])</td></tr><tr><td>last index of</td><td>not builtin; have to reverse list</td><td>const index = arr.lastIndexOf(value[, fromIndex])</td></tr><tr><td>join</td><td>delimiter.join(iterable)</td><td>arr.join(delimiter) returns string</td></tr><tr><td>map</td><td>map(function, iterable)</td><td>const newArr = arr.map(value =&gt; newValue);</td></tr><tr><td>filter</td><td>filter(predicate, iterable)</td><td>const newArr = arr.filter(predicate);</td></tr><tr><td>reduce</td><td>from functools import reduce<br>reduce(lambda acc, item: ..., seq, initial)</td><td>const value = arr.reduce((acc, value) =&gt; { ... });</td></tr><tr><td>any/some</td><td>any(map(predicate, iterable))</td><td>arr.some(predicate) returns boolean</td></tr><tr><td>all/every</td><td>all(map(predicate, iterable))</td><td>arr.every(predicate) returns boolean</td></tr><tr><td>add to end</td><td>seq.append(value)</td><td>arr.push(value);</td></tr><tr><td>remove from end</td><td>seq.pop()</td><td>const value = arr.pop();</td></tr><tr><td>add to start</td><td>seq.insert(0, item)</td><td>arr.unshift(value);</td></tr><tr><td>remove from start</td><td>del seq[0]</td><td>const value = arr.shift();</td></tr><tr><td>remove all</td><td>seq.clear()</td><td>arr = [];</td></tr><tr><td>sort</td><td>list.sort(key=vef)</td><td>arr.sort(comparator);</td></tr><tr><td>change</td><td>combine del and insert above</td><td>arr.splice(start, delCount, v1, v2, ...);</td></tr></tbody></table><p>In the Python list <code>sort</code> method, &quot;vef&quot; is short for value extract function.</p><p>The Python <code>filter</code> and <code>map</code> functions are lazy.<br>To get values from them, pass the result to a function like <code>list</code> or <code>set</code>.<br>For example:</p><pre class="language-python"><code class="language-python">numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><br>doubled <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> n<span class="token punctuation">:</span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> numbers<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>The string <code>join</code> method takes an iterable over strings.<br>To join non-string values, use <code>map</code>. For example:</p><pre class="language-python"><code class="language-python"><span class="token string">'-'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">,</span> numberList<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Python doesn't have a simple, builtin way to find the first item in a list<br>that matches some criteria. This naive approach is probably the most efficient.</p><pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span>aList<span class="token punctuation">,</span> predicate<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  <span class="token keyword">for</span> index <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>aList<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>      <span class="token keyword">if</span> predicate<span class="token punctuation">(</span>aList<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>          <span class="token keyword">return</span> index<br>  <span class="token keyword">return</span> <span class="token boolean">None</span></code></pre><h2>Object Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>get value of key</td><td>dict[key] or dict.get(key)</td><td>obj.key or obj[key]</td></tr><tr><td>get keys</td><td>dict.keys() or list(dict)</td><td>Object.keys(obj)</td></tr><tr><td>get values</td><td>dict.values()</td><td>Object.values(obj)</td></tr><tr><td>get keys and values</td><td>dict.items()</td><td>Object.entries(obj)</td></tr><tr><td>test if key present</td><td>key in dict</td><td>key in obj or obj.hasOwnProperty(key)</td></tr><tr><td>delete key</td><td>del dict[key]</td><td>delete obj.key or delete obj[key]</td></tr><tr><td>delete all keys</td><td>dict.clear()</td><td>obj = {}</td></tr></tbody></table><h2>Function Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>name</td><td>fn.__name__</td><td><a href="http://fn.name">fn.name</a></td></tr><tr><td>required parameter count</td><td>from inspect import getfullargspec<br>len(getfullargspec(fn).args)</td><td>fn.length</td></tr><tr><td>get implementation code</td><td>from inspect import getsource<br>getsource(fn)</td><td>fn.toString()</td></tr><tr><td>bind</td><td>from functools import partial<br>newFn = partial(fn, arg1, arg2, ...)</td><td>const newFn = fn.bind(thisArg, arg1, arg2, ...)</td></tr><tr><td>call</td><td>method(obj, arg1, arg2, ...)</td><td>fn.call(thisArg, arg1, arg2, ...)</td></tr><tr><td>apply</td><td>method(obj, *argList)</td><td>fn.apply(thisArg, argArray)</td></tr></tbody></table><p>The Python <code>partial</code> function cannot be used on methods, only functions.</p><h2>Error Handling</h2><p>Python refers to errors as exceptions.</p><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>throw error</td><td>raise exClass(args)</td><td>throw new Error(message);</td></tr><tr><td>catch error</td><td>try: ... except exClass: ...</td><td>try { ... } catch (e) { ... } finally { ... }</td></tr></tbody></table><h2>JSON Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>create</td><td>jsonString = json.dumps(expr)</td><td>const jsonString = JSON.stringify(expr);</td></tr><tr><td>parse</td><td>value = json.loads(jsonString)</td><td>const value = JSON.parse(jsonString);</td></tr></tbody></table><p>In Python, you must <code>import json</code>.<br>There are many builtin Python exception classes.<br>The base class of all of them is Error.</p><h2>Set Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>create</td><td>{} or set()</td><td>new Set();</td></tr><tr><td>length</td><td></td><td>set.size</td></tr><tr><td>includes</td><td></td><td>set.has(value)</td></tr><tr><td>add</td><td></td><td>set.add(value)</td></tr><tr><td>remove</td><td></td><td>set.delete(value)</td></tr><tr><td>remove all</td><td></td><td>set.clear()</td></tr><tr><td>iterate over</td><td></td><td>set.forEach(value =&gt; { ... });</td></tr><tr><td>convert to array</td><td></td><td>set.values()</td></tr></tbody></table><h2>Map Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>create</td><td></td><td>const map = new Map();</td></tr><tr><td>length</td><td></td><td>map.size</td></tr><tr><td>includes</td><td></td><td>map.has(key)</td></tr><tr><td>add</td><td></td><td>map.set(key, value)</td></tr><tr><td>remove</td><td></td><td>map.delete(key)</td></tr><tr><td>remove all</td><td></td><td>map.clear()</td></tr><tr><td>iterate over</td><td></td><td>map.forEach((value, key) =&gt; { ... });</td></tr><tr><td>convert to array</td><td></td><td>map.values()</td></tr><tr><td>get value for key</td><td></td><td>map.get(key)</td></tr><tr><td>get array of keys</td><td></td><td>map.keys()</td></tr><tr><td>get array of values</td><td></td><td>map.values()</td></tr><tr><td>get array of keys and values</td><td></td><td>map.entries()</td></tr></tbody></table><h2>Regular Expression Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>create</td><td></td><td>/pattern/flags or new RegExp(pattern, flags)</td></tr><tr><td>test if a string matches</td><td></td><td>re.test(str)</td></tr><tr><td>get first matches</td><td></td><td>str.match(re)</td></tr><tr><td>get all matches</td><td></td><td>str.matchAll(re) or re.exec(str)</td></tr></tbody></table><h2>Printing</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>print values</td><td>print(v1, v2, ..)</td><td>console.log(v1, v2, ...);</td></tr><tr><td>print error</td><td></td><td>console.error(message);</td></tr></tbody></table><h2>Popular Frameworks</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>command-line</td><td></td><td>Node.js</td></tr><tr><td>web</td><td></td><td>React, Vue, Svelte</td></tr></tbody></table><h2>Libraries</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>utilities</td><td></td><td>Lodash, Ramda</td></tr><tr><td>web server</td><td>Flask</td><td>Express</td></tr><tr><td>dates and times</td><td></td><td>date.fns, moment</td></tr><tr><td>unit tests</td><td></td><td>Jest, Mocha, Chai, @testing-library</td></tr><tr><td>end-to-end tests</td><td></td><td>Cypress</td></tr><tr><td>math</td><td></td><td>mathjs</td></tr></tbody></table><h2>Python Magic Methods</h2><p>Python magic methods support operator overloading for custom classes.<br>This is a partial list of the magic methods that a Python class can be implement.</p><table><thead><tr><th>Method</th><th>Parameters</th><th>Purpose</th></tr></thead><tbody><tr><td>object lifecycle</td><td></td><td></td></tr><tr><td>__new__</td><td>cls, ...</td><td>creates a new object</td></tr><tr><td>__init__</td><td>self, ...</td><td>initializes a new object</td></tr><tr><td>__del__</td><td>self</td><td>destroys an object</td></tr><tr><td>string representation</td><td></td><td></td></tr><tr><td>__repr__</td><td>self</td><td>returns a string representations useful to developers</td></tr><tr><td>__str__</td><td>self</td><td>returns a string representation useful to users</td></tr><tr><td>comparisons</td><td></td><td></td></tr><tr><td>__cmp__</td><td>self, other</td><td>removed in Python 3</td></tr><tr><td>__ne__</td><td>self, other</td><td>determines if this object is not equal to another</td></tr><tr><td>__eq__</td><td>self, other</td><td>determines if this object is equal to another</td></tr><tr><td>__lt__</td><td>self, other</td><td>determines if this object is &lt; another</td></tr><tr><td>__le__</td><td>self, other</td><td>determines if this object is &lt;= to another</td></tr><tr><td>__gt__</td><td>self, other</td><td>determines if this object is &gt; another</td></tr><tr><td>__ge__</td><td>self, other</td><td>determines if this object is &gt;= to another</td></tr><tr><td>also see functools.total_ordering()</td><td></td><td></td></tr><tr><td>list-like operations</td><td></td><td></td></tr><tr><td>__getitem__</td><td>self, key</td><td>gets an item from a list by index</td></tr><tr><td>__setitem__</td><td>self, key, value</td><td>sets an item in a list by index</td></tr><tr><td>__delitem__</td><td>self, key</td><td>deletes an item from a list by index</td></tr><tr><td>__iter__</td><td>self</td><td>returns an iterator</td></tr><tr><td>__contains__</td><td>self, item</td><td>determines if a given item is contained</td></tr><tr><td>dict operations</td><td></td><td></td></tr><tr><td>__missing__</td><td>self, key</td><td>returns value to use when key is not present</td></tr><tr><td>math operations</td><td></td><td></td></tr><tr><td>__add__</td><td>self, other</td><td>adds an object to another</td></tr><tr><td>__sub__</td><td>self, other</td><td>subtracts an object from another</td></tr><tr><td>__mul__</td><td>self, other</td><td>multiplies an object by another</td></tr><tr><td>__div__</td><td>self, other</td><td>divides an object by another</td></tr><tr><td>__mod__</td><td>self, other</td><td>mods an object by another</td></tr><tr><td>pickling (serialization)</td><td></td><td></td></tr><tr><td>__getstate__</td><td>self</td><td>pickles an object</td></tr><tr><td>__setstate__</td><td>self</td><td>unpickles an object</td></tr><tr><td>other</td><td></td><td></td></tr><tr><td>__call__</td><td>self, ...</td><td>treats an object as a function; can change state</td></tr></tbody></table>