<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Python Compared to JavaScript</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#pros-and-cons">Pros and Cons</a><ol><li><a href="#javascript">JavaScript</a></li><li><a href="#python">Python</a></li></ol></li><li><a href="#comments">Comments</a></li><li><a href="#types">Types</a></li><li><a href="#variables-and-assignment">Variables and Assignment</a></li><li><a href="#more-assignments">More Assignments</a></li><li><a href="#comparison">Comparison</a></li><li><a href="#conditional-logic">Conditional Logic</a></li><li><a href="#iteration">Iteration</a></li><li><a href="#functions">Functions</a></li><li><a href="#classes">Classes</a></li><li><a href="#asynchronous-operations">Asynchronous Operations</a></li><li><a href="#modules">Modules</a></li><li><a href="#boolean-operations">Boolean Operations</a></li><li><a href="#numeric-operations">Numeric Operations</a></li><li><a href="#string-operations">String Operations</a></li><li><a href="#array%2Fsequence-operations">Array/Sequence Operations</a></li><li><a href="#function-operations">Function Operations</a></li><li><a href="#error-handling">Error Handling</a></li><li><a href="#json-operations">JSON Operations</a></li><li><a href="#dict%2Fobject%2Fmap-operations">Dict/Object/Map Operations</a></li><li><a href="#set-operations">Set Operations</a></li><li><a href="#regular-expression-operations">Regular Expression Operations</a></li><li><a href="#printing">Printing</a></li><li><a href="#check-for-running-as-main">Check for running as main</a></li><li><a href="#popular-frameworks">Popular Frameworks</a></li><li><a href="#libraries">Libraries</a></li><li><a href="#python-magic-methods">Python Magic Methods</a></li></ol></nav></aside><article><p>This compares the most commonly used features of Python and JavaScript. Lesser used features are omitted.</p><h2 id="overview">Overview</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>standard</td><td><a href="https://docs.python.org/3/" rel="noopener" target="_blank">Python 3 documentation</a></td><td><a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm" rel="noopener" target="_blank">ECMAScript</a></td></tr><tr><td>evaluation</td><td>dynamic</td><td>dynamic</td></tr><tr><td>performance</td><td>slow</td><td>fast</td></tr><tr><td>style guide</td><td><a href="https://www.python.org/dev/peps/pep-0008/" rel="noopener" target="_blank">PEP 8</a>, <a href="https://pypi.org/project/black/" rel="noopener" target="_blank">Black</a></td><td><a href="https://prettier.io/" rel="noopener" target="_blank">Prettier</a></td></tr><tr><td>most common indentation</td><td>4 spaces</td><td>2 spaces</td></tr><tr><td>type coercion</td><td>must be explicit</td><td>implicit</td></tr></tbody></table><p>Once source of performance benchmarks can be found at <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/which-programs-are-fastest.html" rel="noopener" target="_blank">The Computer Language Benchmarks Game</a>.</p><h2 id="pros-and-cons">Pros and Cons</h2><h3 id="javascript">JavaScript</h3><p>pros:</p><ul><li>performance</li><li>ability to run in web browsers (clients) and from command-line (servers)</li><li>great support for asynchronous code</li><li>more compact syntax for functional programming (ex. functools vs. <code>reduce</code>)</li></ul><p>cons:</p><ul><li>still in transition from require to import syntax in Node.js</li><li>type coercions can result in surprising results if not familiar with them</li></ul><h3 id="python">Python</h3><p>pros:</p><ul><li>quantity and maturity of libraries for machine learning</li><li>multiple number types</li><li>some syntax is easier for beginners<ul><li>ex. <code>and</code> vs. <code>&amp;&amp;</code>.</li><li>ex. <code>println</code> vs. <code>console.log</code></li><li>fewer parentheses and no curly braces or semicolons</li></ul></li></ul><p>cons:</p><ul><li>poor performance</li><li>magic methods (a.k.a. &quot;dunder&quot; for double underscore) such as <code>__init__</code> (see list in &quot;Python Magic Methods&quot; section)</li><li>operator overloading (supported by magic methods)</li><li>lots of documentation and examples are still for V2 instead of V3</li><li>anonymous functions are limited to a single expression</li><li>no built-in support for asynchronous code</li></ul><h2 id="comments">Comments</h2><table><thead><tr><th>Type</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>single-line</td><td>#</td><td>//</td></tr><tr><td>multi-line</td><td>none</td><td>/* */</td></tr></tbody></table><h2 id="types">Types</h2><table><thead><tr><th>Type</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>boolean</td><td><code>True</code>, <code>False</code></td><td><code>true</code>, <code>false</code></td></tr><tr><td>number</td><td><code>int</code>, <code>float</code>, <code>complex</code></td><td>default is double precision float; also <code>BigInt</code></td></tr><tr><td>character</td><td>use string type</td><td>use string type</td></tr><tr><td>string</td><td>'text', &quot;text&quot;, '''text''', or &quot;&quot;&quot;text&quot;&quot;&quot;</td><td>'text' or &quot;text&quot;</td></tr><tr><td>string interpolation</td><td>f'prefix{expr}suffix'</td><td>`prefix${expr}suffix`</td></tr><tr><td>array</td><td>see list, tuple, and range</td><td><code>Array</code>, <code>[v1, v2, ...]</code></td></tr><tr><td>list</td><td><code>[v1, v2, ...]</code>; mutable and homogeneous</td><td>see <code>Array</code></td></tr><tr><td>tuple</td><td><code>(v1, v2, ...)</code>; immutable and heterogeneous</td><td>no equivalent</td></tr><tr><td>range</td><td>range range(start, stop[, step])</td><td>no equivalent</td></tr><tr><td>key/value pairs</td><td>dictionary in the form <code>{'k1': v1, 'k2': v2, ...}</code></td><td>Object in the form <code>{k1: v1, k2: v2, ...}</code> and <code>Map</code></td></tr><tr><td>set</td><td><code>set(v1, v2, ...)</code> or <code>{v1, v2, ...}</code></td><td><code>new Set()</code></td></tr><tr><td>function</td><td>see &quot;Function&quot; section below</td><td>see &quot;Function&quot; section below</td></tr><tr><td>class</td><td><code>class Name:</code></td><td><code>class Name { ... }</code></td></tr><tr><td>regular expression</td><td><code>re.compile(pattern)</code></td><td><code>/pattern/flags</code> or <code>new RegExp(pattern)</code></td></tr><tr><td>no value</td><td><code>None</code></td><td><code>undefined</code> or <code>null</code></td></tr></tbody></table><p>In Python, the following values are treated as false when used in a boolean context: False, None, 0, '', and empty sequences.</p><p>In JavaScript, the following values are treated as false when used in a boolean context: false, 0, '', undefined, null.</p><p>Python has sequences whereas JavaScript has arrays. There are three kinds of sequences: list, tuple, and range. A list is a mutable sequence of values that have the same type. A tuple is an immutable sequence of values that have varying types. A range is an immutable sequence of numbers that can be used for looping.</p><p>JavaScript object keys must be strings. Python dict keys can e any immutable type.</p><h2 id="variables-and-assignment">Variables and Assignment</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>constant</td><td><code>NAME = value</code></td><td><code>const NAME = value;</code></td></tr><tr><td>variable</td><td><code>name = value</code></td><td><code>let name = value;</code></td></tr></tbody></table><p>Python uses a naming convention (all uppercase) to identify constants, but they can still be modified.</p><h2 id="more-assignments">More Assignments</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>spread of array/list</td><td><code>v1, v2 = array</code></td><td><code>const [v1, v2, ...] = array;</code></td></tr><tr><td>spread of object</td><td>not supported</td><td><code>const {k1, k2, ...} = object;</code></td></tr><tr><td>addition</td><td><code>name += expr</code></td><td>same</td></tr><tr><td>subtraction</td><td><code>name -= expr</code></td><td>same</td></tr><tr><td>multiplication</td><td><code>name \*= expr</code></td><td>same</td></tr><tr><td>division</td><td><code>name /= expr</code></td><td>same</td></tr><tr><td>exponentiation</td><td><code>name \*\*= expr</code></td><td>same</td></tr><tr><td>mod (remainder)</td><td><code>name %= expr</code></td><td>same</td></tr><tr><td>logical and</td><td>not supported</td><td><code>name &amp;&amp;= expr</code></td></tr><tr><td>logical or</td><td>not supported</td><td><code>name \|\|= expr</code></td></tr><tr><td>logical xor</td><td>not supported</td><td><code>name ^= expr</code></td></tr><tr><td>bitwise and</td><td><code>name &amp;= expr</code></td><td>same</td></tr><tr><td>bitwise or</td><td><code>name \|= expr</code></td><td>same</td></tr><tr><td>bitwise xor</td><td><code>name ^= expr</code></td><td>same</td></tr><tr><td>signed bit shift</td><td><code>&lt;&lt;=</code> (left), <code>&gt;&gt;=</code> (right)</td><td>same</td></tr><tr><td>unsigned bit shift</td><td>not supported</td><td><code>&lt;&lt;&lt;=</code> (left), <code>&gt;&gt;&gt;=</code> (right)</td></tr></tbody></table><h2 id="comparison">Comparison</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>equal for non-objects</td><td><code>==</code></td><td><code>==</code> (with coercion) or <code>===</code> (without)</td></tr><tr><td>equal of objects</td><td><code>is</code></td><td><code>===</code></td></tr><tr><td>not equal of objects</td><td><code>is not</code></td><td><code>!==</code></td></tr><tr><td>not equal</td><td><code>!=</code></td><td><code>!=</code> (with coercion) or <code>!==</code> (without)</td></tr><tr><td>less than</td><td><code>&lt;</code></td><td>same</td></tr><tr><td>less than or equal</td><td><code>&lt;=</code></td><td>same</td></tr><tr><td>greater than</td><td><code>&gt;</code></td><td>same</td></tr><tr><td>greater than or equal</td><td><code>&gt;=</code></td><td>same</td></tr></tbody></table><h2 id="conditional-logic">Conditional Logic</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>if</td><td><code>if cond:</code></td><td><code>if (cond) stmtOrBlock</code></td></tr><tr><td>if/else</td><td><code>if cond: else:</code></td><td><code>if (cond) { trueBlock } else { falseBlock}</code></td></tr><tr><td>ternary</td><td><code>trueValue if cond else falseValue</code></td><td><code>cond ? trueValue : falseValue</code></td></tr></tbody></table><h2 id="iteration">Iteration</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>classic</td><td><code>for var in range(start, stop[, step]):</code></td><td><code>for (let var = initial; cond; statements)</code></td></tr><tr><td>over collection</td><td><code>for value in sequence:</code></td><td><code>for (const value of iterable)</code></td></tr><tr><td>over object/dict keys</td><td><code>for key in dict.keys():</code></td><td><code>for (const key of Object.keys(obj))</code></td></tr><tr><td>over object/dict values</td><td><code>for value in dict.values():</code></td><td><code>for (const value of Object.values(obj))</code></td></tr><tr><td>over object/dict keys and values</td><td><code>for key, value in dict.items():</code></td><td><code>for (const [key, value] of Object.entries(obj))</code></td></tr><tr><td>top-tested</td><td><code>while cond:</code></td><td><code>while (cond)</code></td></tr><tr><td>bottom-tested</td><td><code>while True: ... if !cond: break</code></td><td><code>do { ... } while (cond);</code></td></tr></tbody></table><h2 id="functions">Functions</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>named definition</td><td><code>def name(params):</code></td><td><code>function name(params) { definition }</code></td></tr><tr><td>anonymous definition</td><td><code>lambda params: expression</code></td><td><code>const name = (params) =&gt; definition</code></td></tr><tr><td>anonymous single parameter</td><td>same as above</td><td><code>const name = param =&gt; { ... }</code></td></tr><tr><td>anonymous single expression</td><td>same as above</td><td><code>const name = (params) =&gt; expr</code></td></tr><tr><td>variable arguments</td><td><code>def name(p1, p2, \*rest):</code></td><td><code>function name(p1, p2, ...rest) { ...}</code></td></tr><tr><td>return type</td><td>not specified; return a single value<br>that can be an object or array</td><td>same as Python</td></tr><tr><td>calling</td><td><code>name(args)</code></td><td><code>name(args)</code></td></tr></tbody></table><p>Note that unlike JavaScript arrow functions, Python lambdas can only use a single expression, not a block of code.</p><h2 id="classes">Classes</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>defining</td><td><code>class Name:</code></td><td><code>class Name { ... }</code></td></tr><tr><td>inheritance</td><td><code>class Sub(Super1, Super2, ...)</code></td><td><code>class Sub extends Super { ... }</code></td></tr><tr><td>constructor</td><td><code>def \_\_init\_\_(self, params):</code></td><td><code>constructor(params) { ... }</code></td></tr><tr><td>instance property declaration</td><td>not declared; set in __init__ on <code>self</code></td><td>not declared; set in constructor on <code>this</code></td></tr><tr><td>instance property reference</td><td><code>self.propName</code></td><td><code>this.propName</code></td></tr><tr><td>class/static property declaration</td><td><code>propName = value;</code></td><td><code>static propName = value;</code></td></tr><tr><td>class/static property reference</td><td><code>CName.propName</code> or <code>instance.propName</code></td><td><code>CName.propName</code></td></tr><tr><td>instance method</td><td><code>def name(params):</code></td><td><code>name(params) { ... }</code></td></tr><tr><td>class/static method declaration</td><td><code>@staticmethod</code><br><code>def methodName(params):</code></td><td><code>static methodName(params) { ... }</code></td></tr><tr><td>class/static method call</td><td><code>CName.methodName(params)</code> or <code>inst.methodName(params)</code></td><td><code>CName.methodName(params)</code></td></tr><tr><td>instantiating</td><td><code>object = CName(args)</code></td><td><code>const object = new CName(args);</code></td></tr></tbody></table><p>JavaScript does not support multiple inheritance, but Python does. In addition to the <code>@staticmethod</code> decorator, Python also supports the <code>@classmethod</code> decorator. The difference is that methods defined with the latter are passed the class as the first argument.</p><h2 id="asynchronous-operations">Asynchronous Operations</h2><p>TODO: You said earlier that this isn't supported in Python! Is it?</p><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>async named function</td><td><code>async def name(params):</code></td><td><code>async function name(params) { ... }</code></td></tr><tr><td>async anonymous function</td><td>not supported</td><td><code>const name = async (params) =&gt; { ... }</code></td></tr><tr><td>async call with await</td><td><code>result = await name(args)</code></td><td><code>const result = await name(args);</code></td></tr><tr><td>async call with then</td><td>n/a</td><td><code>name(args).then(result =&gt; { ... });</code></td></tr></tbody></table><p>In JavaScript, async functions return a Promise. In Python, async function return a coroutine which is similar. Python doesn't seem to have to equivalent of the JavaScript Promise methods <code>then</code> and <code>catch</code>.</p><h2 id="modules">Modules</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>defining</td><td>content of file</td><td>content of file</td></tr><tr><td>export</td><td>everything is automatically exported</td><td>export name = value;</td></tr><tr><td>default export</td><td>not supported</td><td>export default name = value;</td></tr><tr><td>import default</td><td>not supported</td><td>import name from 'path';</td></tr><tr><td>import named</td><td>from moduleName import name1, name2</td><td>import {name1, name2} from 'path';</td></tr><tr><td>import both</td><td>n/a</td><td>import name, {name1, name2} from 'path';</td></tr><tr><td>where to find</td><td>pip</td><td>npm</td></tr></tbody></table><h2 id="boolean-operations">Boolean Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>and</td><td>b1 and b2</td><td>b1 &amp;&amp; b2</td></tr><tr><td>or</td><td>b1 or b2</td><td>b1 || b2</td></tr><tr><td>not</td><td>not b</td><td>!b</td></tr><tr><td>bitwise and</td><td>b1 &amp; b2</td><td>b1 &amp; b2</td></tr><tr><td>bitwise or</td><td>b1 | b2</td><td>b1 | b2</td></tr><tr><td>bitwise not</td><td>~b</td><td>~b</td></tr><tr><td>bitwise xor</td><td>b1 &amp; b2</td><td>b1 ^ b2</td></tr></tbody></table><h2 id="numeric-operations">Numeric Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>basic</td><td>+, -, *, /</td><td>+, -, *, /</td></tr><tr><td>exponentiation</td><td>**</td><td>**</td></tr><tr><td>increment</td><td>v += 1</td><td>++n1 (pre) or n1++ (post)</td></tr><tr><td>decrement</td><td>v -= 1</td><td>--n1 (pre) or n1-- (post)</td></tr><tr><td>mod (remainder)</td><td>%</td><td>%</td></tr><tr><td>convert to string</td><td>str(n)</td><td>n.toString()</td></tr><tr><td>convert to string with fixed decimals</td><td>&quot;{:.2f}&quot;.format(n)</td><td>n.toFixed(decimals)</td></tr><tr><td>convert to hex</td><td>hex(n)</td><td>n.toString(16)</td></tr><tr><td>convert from hex</td><td>int(hexString, 16)</td><td>parseInt(hexString, 16)</td></tr><tr><td>constants</td><td>see math module</td><td>see Math and Number global objects</td></tr><tr><td>functions</td><td>see math module</td><td>see Math and Number global objects</td></tr></tbody></table><h2 id="string-operations">String Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>concatenation</td><td>s1 + str(n1)</td><td>s1 + n1</td></tr><tr><td>lowercase</td><td>s.lower()</td><td>s.toLowerCase()</td></tr><tr><td>uppercase</td><td>s.upper()</td><td>s.toUpperCase()</td></tr><tr><td>substring</td><td>s[start:end] or s[start:] or s[:end]</td><td>s1.substring(start[, end])</td></tr><tr><td>slice</td><td>same as above</td><td>like substring, but supports negative indexes</td></tr><tr><td>split</td><td>s.split(delimiter) returns list</td><td>s.split(delimiter) returns array</td></tr><tr><td>starts with</td><td>s.startswith(sub)</td><td>s.startsWith(sub) returns boolean</td></tr><tr><td>ends with</td><td>s.endswith(sub)</td><td>s.endsWith(sub) returns boolean</td></tr><tr><td>contains</td><td>sub in s</td><td>s.includes(sub) returns boolean</td></tr><tr><td>index of</td><td>s.index(sub[, start[, end]])</td><td>s.indexOf(sub) returns number</td></tr><tr><td>last index of</td><td>s.rindex(sub[, start[, end]])</td><td>s.lastIndexOf(sub) returns number</td></tr><tr><td>compare</td><td>not supported</td><td>s.localeCompare(sub) returns -1, 0, or 1</td></tr><tr><td>replace first</td><td>s.replace(old, new, 1)</td><td>s.replace(oldSub, newSub)</td></tr><tr><td>replace all</td><td>s.replace(old, new)</td><td>s.replaceAll(oldSub, newSub)</td></tr><tr><td>trim start</td><td>s.lstrip()</td><td>s.trimStart()</td></tr><tr><td>trim end</td><td>s.rstrip()</td><td>s.trimEnd()</td></tr><tr><td>trim both</td><td>s.strip()</td><td>s.trim()</td></tr></tbody></table><h2 id="array%2Fsequence-operations">Array/Sequence Operations</h2><p>Some Python sequence operations apply to all three of kinds of sequences (list, tuple, and range).</p><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>is array/sequence</td><td>hasattr(type(obj), '__iter__')</td><td>Array.isArray(expression)</td></tr><tr><td>length</td><td>len(seq)</td><td>arr.length</td></tr><tr><td>lookup</td><td>value = seq[index]</td><td>const value = arr[index];</td></tr><tr><td>subset</td><td>newSeq = seq[startIndex:endIndex]</td><td>const newArr = arr.slice(startIndex[, endIndex]);</td></tr><tr><td>concat</td><td>newSeq = seq1 + seq2</td><td>const newArr = arr1.concat(arr2, arr3, ...);</td></tr><tr><td>find</td><td>next(filter(predicate, iterable))</td><td>const value = arr.find(predicate);</td></tr><tr><td>find index</td><td>see note below this table</td><td>const index = arr.findIndex(predicate);</td></tr><tr><td>for each</td><td>for item in seq:</td><td>arr.forEach(value =&gt; { ... });</td></tr><tr><td>includes</td><td>value in seq</td><td>arr.includes(value) returns boolean</td></tr><tr><td>not includes</td><td>value not in seq</td><td>!arr.includes(value) returns boolean</td></tr><tr><td>index of</td><td>seq.index(value[, start[, end]])</td><td>const index = arr.indexOf(value[, fromIndex])</td></tr><tr><td>last index of</td><td>not builtin; have to reverse list</td><td>const index = arr.lastIndexOf(value[, fromIndex])</td></tr><tr><td>join</td><td>delimiter.join(iterable)</td><td>arr.join(delimiter) returns string</td></tr><tr><td>map</td><td>iterator = map(function, iterable)</td><td>const newArr = arr.map(value =&gt; newValue);</td></tr><tr><td>filter</td><td>iterator = filter(predicate, iterable)</td><td>const newArr = arr.filter(predicate);</td></tr><tr><td>reduce</td><td>from functools import reduce<br>value = reduce(lambda acc, item: ..., seq, initial)</td><td>const value = arr.reduce((acc, value) =&gt; { ... });</td></tr><tr><td>any/some</td><td>any(map(predicate, iterable))</td><td>arr.some(predicate) returns boolean</td></tr><tr><td>all/every</td><td>all(map(predicate, iterable))</td><td>arr.every(predicate) returns boolean</td></tr><tr><td>add to end</td><td>seq.append(value)</td><td>arr.push(value);</td></tr><tr><td>remove from end</td><td>seq.pop()</td><td>const value = arr.pop();</td></tr><tr><td>add to start</td><td>seq.insert(0, item)</td><td>arr.unshift(value);</td></tr><tr><td>remove from start</td><td>del seq[0]</td><td>const value = arr.shift();</td></tr><tr><td>remove all</td><td>seq.clear()</td><td>arr = [];</td></tr><tr><td>sort</td><td>list.sort(key=vef)</td><td>arr.sort(comparator);</td></tr><tr><td>change</td><td>combine del and insert above</td><td>arr.splice(start, delCount, v1, v2, ...);</td></tr></tbody></table><p>In the Python list <code>sort</code> method, &quot;vef&quot; is short for value extract function.</p><p>The Python <code>filter</code> and <code>map</code> functions are lazy. JavaScript does not provide lazy evaluations. To get values from them, pass the result to a function like <code>list</code> or <code>set</code>. For example:</p><pre class="language-python"><code class="language-python">numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><br>doubled <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> n<span class="token punctuation">:</span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> numbers<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>The string <code>join</code> method takes an iterable over strings. To join non-string values, use <code>map</code>. For example:</p><pre class="language-python"><code class="language-python"><span class="token string">'-'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">,</span> numberList<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Python doesn't have a simple, builtin way to find the first item in a list that matches some criteria. This naive approach is probably the most efficient.</p><pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span>aList<span class="token punctuation">,</span> predicate<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  <span class="token keyword">for</span> index <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>aList<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>      <span class="token keyword">if</span> predicate<span class="token punctuation">(</span>aList<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>          <span class="token keyword">return</span> index<br>  <span class="token keyword">return</span> <span class="token boolean">None</span></code></pre><h2 id="function-operations">Function Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>name</td><td>fn.__name__</td><td><a href="http://fn.name">fn.name</a></td></tr><tr><td>required parameter count</td><td>from inspect import getfullargspec<br>len(getfullargspec(fn).args)</td><td>fn.length</td></tr><tr><td>get implementation code</td><td>from inspect import getsource<br>getsource(fn)</td><td>fn.toString()</td></tr><tr><td>bind</td><td>from functools import partial<br>newFn = partial(fn, arg1, arg2, ...)</td><td>const newFn = fn.bind(thisArg, arg1, arg2, ...)</td></tr><tr><td>call</td><td>method(obj, arg1, arg2, ...)</td><td>fn.call(thisArg, arg1, arg2, ...)</td></tr><tr><td>apply</td><td>method(obj, *argList)</td><td>fn.apply(thisArg, argArray)</td></tr></tbody></table><p>The Python <code>partial</code> function cannot be used on methods, only functions.</p><h2 id="error-handling">Error Handling</h2><p>Python refers to errors as exceptions.</p><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>throw error</td><td>raise exClass(args)</td><td>throw new Error(message);</td></tr><tr><td>catch error</td><td>try: ... except exClass: ...</td><td>try { ... } catch (e) { ... } finally { ... }</td></tr></tbody></table><h2 id="json-operations">JSON Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>create</td><td>jsonString = json.dumps(expr)</td><td>const jsonString = JSON.stringify(expr);</td></tr><tr><td>parse</td><td>value = json.loads(jsonString)</td><td>const value = JSON.parse(jsonString);</td></tr></tbody></table><p>In Python, you must <code>import json</code>. There are many builtin Python exception classes. The base class of all of them is Error.</p><h2 id="dict%2Fobject%2Fmap-operations">Dict/Object/Map Operations</h2><p>To store associations between keys and values, Python uses &quot;dictionaries&quot;.</p><table><thead><tr><th>Operation</th><th>Python</th></tr></thead><tbody><tr><td>create</td><td><code>dict = {}</code></td></tr><tr><td>get length</td><td><code>len(dict)</code></td></tr><tr><td>set value of key</td><td><code>dict[key] = value</code></td></tr><tr><td>get value of key</td><td><code>dict[key]</code> or <code>dict.get(key)</code></td></tr><tr><td>get all keys</td><td><code>dict.keys()</code> or <code>list(dict)</code></td></tr><tr><td>get all values</td><td><code>dict.values()</code></td></tr><tr><td>get all keys and values</td><td><code>dict.items()</code></td></tr><tr><td>test if key present</td><td><code>key in dict</code></td></tr><tr><td>delete key</td><td><code>del dict[key]</code></td></tr><tr><td>delete all keys</td><td><code>dict.clear()</code></td></tr><tr><td>iterate over</td><td><code>for item in dict.items():</code></td></tr></tbody></table><p>JavaScript uses plain objects or instances of the <code>Map</code> class to store associations between keys and values. The keys in JavaScript objects must be must be strings, integers, or symbols, but keys in <code>Map</code> instances can be any type.</p><table><thead><tr><th>Operation</th><th>JavaScript Object</th><th>JavaScript Map</th></tr></thead><tbody><tr><td>create</td><td><code>const obj = {};</code></td><td><code>const map = new Map();</code></td></tr><tr><td>get length</td><td><code>Object.keys(obj).length</code></td><td><code>map.size</code></td></tr><tr><td>set value of key</td><td><code>obj.key = value</code> or <code>obj[key] = value</code></td><td><code>map.set(key, value)</code></td></tr><tr><td>get value of key</td><td><code>obj.key</code> or <code>obj[key]</code></td><td><code>map.get(key)</code></td></tr><tr><td>get all keys</td><td><code>Object.keys(obj)</code></td><td><code>map.keys()</code></td></tr><tr><td>get all values</td><td><code>Object.values(obj)</code></td><td><code>map.values()</code></td></tr><tr><td>get all keys and values</td><td><code>Object.entries(obj)</code></td><td><code>map.entries()</code></td></tr><tr><td>test if key present</td><td><code>key in obj</code> or <code>obj.hasOwnProperty(key)</code></td><td><code>map.has(key)</code></td></tr><tr><td>delete key</td><td><code>delete obj.key</code> or <code>delete obj[key]</code></td><td><code>map.delete(key)</code></td></tr><tr><td>delete all keys</td><td><code>obj = {}</code></td><td><code>map.clear()</code></td></tr><tr><td>iterate over</td><td><code>for (const prop in obj)</code></td><td><code>map.forEach((value, key) =&gt; { ... });</code></td></tr></tbody></table><h2 id="set-operations">Set Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>create</td><td><code>s = {values}</code> or <code>s = set(values)</code></td><td><code>const s = new Set();</code></td></tr><tr><td>length</td><td><code>len(s)</code></td><td><code>s.size</code></td></tr><tr><td>includes</td><td><code>value in s</code></td><td><code>s.has(value)</code></td></tr><tr><td>add</td><td><code>s.add(value)</code></td><td>same</td></tr><tr><td>remove</td><td><code>s.remove(value)</code></td><td><code>s.delete(value);</code></td></tr><tr><td>remove all</td><td><code>s.clear()</code></td><td>same</td></tr><tr><td>iterate over</td><td><code>for value in set:</code></td><td><code>s.forEach(value =&gt; { ... });</code></td></tr><tr><td>convert to list/array</td><td><code>l = list(s)</code></td><td><code>a = s.values();</code></td></tr></tbody></table><h2 id="regular-expression-operations">Regular Expression Operations</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>create</td><td></td><td>/pattern/flags or new RegExp(pattern, flags)</td></tr><tr><td>test if a string matches</td><td></td><td>re.test(str)</td></tr><tr><td>get first matches</td><td></td><td>str.match(re)</td></tr><tr><td>get all matches</td><td></td><td>str.matchAll(re) or re.exec(str)</td></tr></tbody></table><h2 id="printing">Printing</h2><table><thead><tr><th>Operation</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>print values</td><td>print(v1, v2, ..) or println(v1, v2, ...)</td><td>console.log(v1, v2, ...);</td></tr><tr><td>print error</td><td></td><td>console.error(message);</td></tr></tbody></table><h2 id="check-for-running-as-main">Check for running as main</h2><p>In Python, use <code>if __name__ == '__main__':</code>. In Node.js, use <code>if (require.main === module) {</code>.</p><h2 id="popular-frameworks">Popular Frameworks</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>command-line</td><td></td><td>Node.js</td></tr><tr><td>web</td><td>Flask</td><td>React, Vue, Svelte</td></tr></tbody></table><h2 id="libraries">Libraries</h2><table><thead><tr><th>Topic</th><th>Python</th><th>JavaScript</th></tr></thead><tbody><tr><td>utilities</td><td></td><td>Lodash, Ramda</td></tr><tr><td>web server</td><td>Flask</td><td>Express</td></tr><tr><td>dates and times</td><td></td><td>date.fns, moment</td></tr><tr><td>unit tests</td><td></td><td>Jest, Mocha, Chai, @testing-library</td></tr><tr><td>end-to-end tests</td><td></td><td>Cypress</td></tr><tr><td>math</td><td></td><td>mathjs</td></tr></tbody></table><h2 id="python-magic-methods">Python Magic Methods</h2><p>Python magic methods support operator overloading for custom classes. This is a partial list of the magic methods that a Python class can be implement.</p><table><thead><tr><th>Method</th><th>Parameters</th><th>Purpose</th></tr></thead><tbody><tr><td>object lifecycle</td><td></td><td></td></tr><tr><td>__new__</td><td>cls, ...</td><td>creates a new object</td></tr><tr><td>__init__</td><td>self, ...</td><td>initializes a new object</td></tr><tr><td>__del__</td><td>self</td><td>destroys an object</td></tr><tr><td>string representation</td><td></td><td></td></tr><tr><td>__repr__</td><td>self</td><td>returns a string representations useful to developers</td></tr><tr><td>__str__</td><td>self</td><td>returns a string representation useful to users</td></tr><tr><td>comparisons</td><td></td><td></td></tr><tr><td>__cmp__</td><td>self, other</td><td>removed in Python 3</td></tr><tr><td>__ne__</td><td>self, other</td><td>determines if this object is not equal to another</td></tr><tr><td>__eq__</td><td>self, other</td><td>determines if this object is equal to another</td></tr><tr><td>__lt__</td><td>self, other</td><td>determines if this object is &lt; another</td></tr><tr><td>__le__</td><td>self, other</td><td>determines if this object is &lt;= to another</td></tr><tr><td>__gt__</td><td>self, other</td><td>determines if this object is &gt; another</td></tr><tr><td>__ge__</td><td>self, other</td><td>determines if this object is &gt;= to another</td></tr><tr><td>also see functools.total_ordering()</td><td></td><td></td></tr><tr><td>list-like operations</td><td></td><td></td></tr><tr><td>__getitem__</td><td>self, key</td><td>gets an item from a list by index</td></tr><tr><td>__setitem__</td><td>self, key, value</td><td>sets an item in a list by index</td></tr><tr><td>__delitem__</td><td>self, key</td><td>deletes an item from a list by index</td></tr><tr><td>__iter__</td><td>self</td><td>returns an iterator</td></tr><tr><td>__contains__</td><td>self, item</td><td>determines if a given item is contained</td></tr><tr><td>dict operations</td><td></td><td></td></tr><tr><td>__missing__</td><td>self, key</td><td>returns value to use when key is not present</td></tr><tr><td>math operations</td><td></td><td></td></tr><tr><td>__add__</td><td>self, other</td><td>adds an object to another</td></tr><tr><td>__sub__</td><td>self, other</td><td>subtracts an object from another</td></tr><tr><td>__mul__</td><td>self, other</td><td>multiplies an object by another</td></tr><tr><td>__div__</td><td>self, other</td><td>divides an object by another</td></tr><tr><td>__mod__</td><td>self, other</td><td>mods an object by another</td></tr><tr><td>pickling (serialization)</td><td></td><td></td></tr><tr><td>__getstate__</td><td>self</td><td>pickles an object</td></tr><tr><td>__setstate__</td><td>self</td><td>unpickles an object</td></tr><tr><td>other</td><td></td><td></td></tr><tr><td>__call__</td><td>self, ...</td><td>treats an object as a function; can change state</td></tr></tbody></table></article>