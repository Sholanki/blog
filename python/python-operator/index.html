<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Python operator module</h2><aside><nav class="toc"><ol><li><a href="#relational">Relational</a></li><li><a href="#arithmetic">Arithmetic</a></li><li><a href="#bitwise">Bitwise</a></li><li><a href="#indexing">Indexing</a></li><li><a href="#creating-retrieval-functions">Creating retrieval functions</a></li><li><a href="#slicing">Slicing</a></li><li><a href="#other">Other</a></li></ol></nav></aside><article><p>The <a href="https://docs.python.org/3/library/operator.html" rel="noopener" target="_blank"><code>operator</code></a> module in the Python standard library that provides that implement standard Python operators. These are useful for passing to higher-order functions. For example, .. TODO</p><p>The tables below show standard Python operators and their equivalent function from the <code>operator</code> module.</p><h2 id="relational">Relational</h2><table><thead><tr><th>Operator</th><th>Function</th></tr></thead><tbody><tr><td><code>a &lt; b</code></td><td><code>lt(a, b)</code></td></tr><tr><td><code>a &lt;= b</code></td><td><code>le(a, b)</code></td></tr><tr><td><code>a == b</code></td><td><code>eq(a, b)</code></td></tr><tr><td><code>a != b</code></td><td><code>ne(a, b)</code></td></tr><tr><td><code>a &gt;= b</code></td><td><code>ge(a, b)</code></td></tr><tr><td><code>a &gt; b</code></td><td><code>gt(a, b)</code></td></tr></tbody></table><h2 id="arithmetic">Arithmetic</h2><table><thead><tr><th>Operator</th><th>Function</th></tr></thead><tbody><tr><td><code>-a</code></td><td><code>neg(a)</code></td></tr><tr><td><code>+a</code></td><td><code>pos(a)</code></td></tr><tr><td><code>a + b</code></td><td><code>add(a, b)</code></td></tr><tr><td><code>a - b</code></td><td><code>sub(a, b)</code></td></tr><tr><td><code>a * b</code></td><td><code>mul(a, b)</code></td></tr><tr><td><code>a / b</code></td><td><code>truediv(a, b)</code></td></tr><tr><td><code>a // b</code></td><td><code>floordiv(a, b)</code></td></tr><tr><td><code>a % b</code></td><td><code>mod(a, b)</code></td></tr><tr><td><code>a ** b</code></td><td><code>pow(a, b)</code></td></tr></tbody></table><h2 id="bitwise">Bitwise</h2><table><thead><tr><th>Operator</th><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><code>a &amp; b</code></td><td><code>and_(a, b)</code></td><td>bitwise and;<br>note trailing underscore in name</td></tr><tr><td><code>a | b</code></td><td><code>or_(a, b)</code></td><td>bitwise or;<br>note trailing underscore in name</td></tr><tr><td><code>a ^ b</code></td><td><code>xor(a, b)</code></td><td>bitwise exclusive or</td></tr><tr><td><code>~a</code></td><td><code>inv(a)</code> or <code>invert(a)</code></td><td>bitwise inversion</td></tr><tr><td><code>a &lt;&lt; b</code></td><td><code>lshift(a, b)</code></td><td>left shift</td></tr><tr><td><code>a &gt;&gt; b</code></td><td><code>rshift(a, b)</code></td><td>right shift</td></tr></tbody></table><h2 id="indexing">Indexing</h2><table><thead><tr><th>Operator</th><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><code>obj[k]</code></td><td><code>getitem(obj, k)</code></td><td>indexed retrieval</td></tr><tr><td><code>obj[k] = v</code></td><td><code>setitem(obj, k, v)</code></td><td>indexed assignment</td></tr><tr><td><code>del obj[k]</code></td><td><code>delitem(obj, k)</code></td><td>indexed deletion</td></tr></tbody></table><h2 id="creating-retrieval-functions">Creating retrieval functions</h2><table><thead><tr><th>Operator</th><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><code>obj.name</code></td><td><code>attrgetter(name)(obj)</code></td><td>returns attribute value from object<br><code>attrgetter</code> returns a function</td></tr><tr><td>n/a</td><td><code>attrgetter(name1, name2, ...)(obj)</code></td><td>returns tuple of attribute values from object</td></tr><tr><td><code>seq[i]</code></td><td><code>itemgetter(i)(seq)</code></td><td>returns i'th value from sequence<br><code>itemgetter</code> returns a function</td></tr><tr><td>n/a</td><td><code>itemgetter(i1, i2, ...)(obj)</code></td><td>returns tuple of values from sequence</td></tr><tr><td>n/a</td><td><code>methodcaller(name, args)(obj)</code></td><td>calls a method with given arguments on an object</td></tr></tbody></table><h2 id="slicing">Slicing</h2><table><thead><tr><th>Operator</th><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><code>seq[i:j]</code></td><td><code>getitem(seq, slice(i, j))</code></td><td>slice retrieval</td></tr><tr><td><code>seq[i:j] = values</code></td><td><code>setitem(seq, slice(i, j), values)</code></td><td>slice assignment</td></tr><tr><td><code>del seq[i:j]</code></td><td><code>delitem(seq, slice(i, j))</code></td><td>slice deletion</td></tr></tbody></table><h2 id="other">Other</h2><table><thead><tr><th>Operator</th><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><code>a + b</code></td><td><code>concat(a, b)</code></td><td>returns new sequence created by concatenating two others</td></tr><tr><td><code>v in seq</code></td><td><code>contains(v, seq)</code></td><td>determine if <code>v</code> is in <code>seq</code></td></tr><tr><td>n/a</td><td><code>countOf(a, b)</code></td><td>returns number of occurrences of b in a;<br>note camelCase name</td></tr><tr><td><code>a is b</code></td><td><code>is_(a, b)</code></td><td>determines if a and b are the same object in memory;<br>note trailing underscore in name</td></tr><tr><td><code>a is not b</code></td><td><code>is_not(a, b)</code></td><td>determines if a and b are not the same object in memory</td></tr><tr><td><code>a @ b</code></td><td><code>matmul(a, b)</code></td><td>matrix multiplication</td></tr><tr><td><code>s % obj</code></td><td><code>mod(s, obj)</code></td><td>string formatting (SEEMS WRONG!)</td></tr><tr><td><code>v</code> evaluated in<br>Boolean context</td><td><code>truth(v)</code></td><td>returns the boolean value of v;<br>same as <code>bool(v)</code></td></tr><tr><td><code>not v</code></td><td><code>not_(v)</code></td><td>returns the negated boolean value of v;<br>note trailing underscore in name</td></tr><tr><td>n/a</td><td><code>length_hint(seq)</code></td><td>returns estimated number of elements, not length in bytes;<br>Why estimated?</td></tr></tbody></table></article>