<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>Python testing</h2><aside><nav class="toc"><ol><li><a href="#unit-tests">Unit tests</a><ol><li><a href="#pytest">pytest</a></li><li><a href="#unittest">unittest</a></li><li><a href="#nose2">nose2</a></li></ol></li><li><a href="#code-coverage">Code coverage</a><ol><li><a href="#codecov">codecov</a></li><li><a href="#coverage">coverage</a></li></ol></li><li><a href="#end-to-end-tests">End-to-end tests</a></li></ol></nav></aside><article><p>Packages that support implementing tests for Python code are described below.</p><h2 id="unit-tests">Unit tests</h2><h3 id="pytest">pytest</h3><p>The <a href="https://pytest.org" rel="noopener" target="_blank">pytest</a> framework runs unit tests of Python code and reports test results. It can also run tests written with the unittest and nose test frameworks.</p><p>To install pytest, enter <code>pip install pytest</code>.</p><p>The names of test source files should begin with <code>test_</code> and often match the filename of the source file they test. For example, tests for <code>math_util.py</code> should go in <code>test_math_util.py</code>.</p><p>Tests make assertions using the Python language <code>assert</code> keyword. This is followed by an expression that is evaluated as a boolean. If it evaluates to <code>True</code>, nothing happens. If it evaluates to <code>False</code>, an <code>AssertionError</code> is raised. Test frameworks like pytest catch those in order to report test failures. For example:</p><pre class="language-python"><code class="language-python"><span class="token keyword">assert</span> average<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2.5</span></code></pre><p>To test code that is expected to raise an exception, use the <code>pytest.raises</code> function. For example:</p><pre class="language-python"><code class="language-python"><span class="token keyword">with</span> pytest<span class="token punctuation">.</span>raises<span class="token punctuation">(</span>ZeroDivisionError<span class="token punctuation">)</span><span class="token punctuation">:</span><br>    average<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>To run tests, enter <code>pytest</code>. For more brief output, add the <code>--quiet</code> (<code>-q</code>) option.</p><p>By default anything written to stdout is &quot;captured&quot;. To avoid this and make the output is visible, add the <code>--captured=no</code> or <code>-s</code> option.</p><p>To run setup and teardown code, define the following functions that each have no parameters:</p><ul><li><code>setup_module</code> - run once before all the test functions are run</li><li><code>setup_function</code> - run once before each test function is run</li><li><code>teardown_function</code> - run once after each test function is run</li><li><code>teardown_module</code> - run once after all the test functions are run</li></ul><p>Fixtures are special functions that retrieves or generates data that is used by multiple tests. A function becomes a fixture when it is marked with the <code>@pytest.fixture</code> decorator. Their result is cached in a particular scope and the function is not run again until ???.</p><p>For example:</p><pre class="language-python"><code class="language-python"><span class="token decorator annotation punctuation">@pytest<span class="token punctuation">.</span>fixture</span><br><span class="token keyword">def</span> <span class="token function">numbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><br><br><span class="token keyword">def</span> <span class="token function">test_add_with_fixture</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">:</span><br>    <span class="token keyword">assert</span> add<span class="token punctuation">(</span><span class="token operator">*</span>numbers<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">6</span></code></pre><p>To watch files for changes and automatically rerun tests, use <a href="https://github.com/joeyespo/pytest-watch" rel="noopener" target="_blank">pytest-watch</a>. To install it, enter <code>pip install pytest-watch</code>. To run tests in watch mode, enter <code>ptw</code>. Options after <code>--</code> are passed on to <code>pytest</code>. To run them in quiet mode, enter <code>ptw -- -q</code>.</p><h3 id="unittest">unittest</h3><p>unittest is in the Python standard library, so does not need to be installed.</p><h3 id="nose2">nose2</h3><p>TODO: Add content</p><h2 id="code-coverage">Code coverage</h2><p>TODO: Add content</p><h3 id="codecov">codecov</h3><p>TODO: Add content</p><h3 id="coverage">coverage</h3><p>TODO: Add content</p><h2 id="end-to-end-tests">End-to-end tests</h2><p>There is nothing Python-specific about implementing end-to-end tests. For web applications, <a href="https://www.cypress.io/" rel="noopener" target="_blank">Cypress</a> is recommended.</p></article>