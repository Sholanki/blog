<link rel="preload" as="style" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/prism-a11y.css"><link rel="stylesheet" href="/blog/assets/topic.css"><script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><h2>NumPy</h2><aside><nav class="toc"><ol><li><a href="#overview">Overview</a></li><li><a href="#using-numpy">Using NumPy</a></li><li><a href="#creating-a-numpy-array">Creating a NumPy Array</a></li><li><a href="#getting-information-about-an-array">Getting Information About an Array</a></li><li><a href="#element-access">Element Access</a></li><li><a href="#operations-on-one-array">Operations on One Array</a></li><li><a href="#operations-on-two-arrays">Operations on Two Arrays</a></li></ol></nav></aside><article><h2 id="overview">Overview</h2><p><a href="https://numpy.org/" rel="noopener" target="_blank">NumPy</a> is a Python library for scientific computing. It is an alternative to MatLab.</p><p>NumPy is a dependency of the pandas package, so if you have installed that, you already have NumPy. Otherwise, install it by entering <code>pip install numpy</code>.</p><p>A primary feature of NumPy is that it uses NumPy arrays to store and operate on data. These have many advantages over Python lists including:</p><ul><li>Type checking of each element is not needed because NumPy arrays are homogeneous.</li><li>Memory requirements are smaller because the representation of each data value requires less bytes than the equivalent Python representation.</li><li>NumPy array elements are stored in contiguous memory, so access is faster.</li><li>Some operations on element values can be performed in parallel by taking advantage of Single Instruction, Multiple Data (SIMD) vector processing.</li><li>Memory caching can be more effective utilized which results in faster element access.</li></ul><p>NumPy supports many operations on matrices. SciPy supports even more. Is it seen as a superset of NumPy?</p><h2 id="using-numpy">Using NumPy</h2><pre class="language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np</code></pre><h2 id="creating-a-numpy-array">Creating a NumPy Array</h2><p>Many function described below accept a <code>dtype</code> argument to specify the data type of the array elements. When this is not specified, the data type is inferred or has a default.</p><p>In all function below that accept a number of rows and columns, any number of dimension sizes can be specified, including one.</p><table><thead><tr><th>To create ...</th><th>Use ...</th></tr></thead><tbody><tr><td>1D array from a list</td><td><code>a = np.array([v1, v2, ...])</code></td></tr><tr><td>1D array from a tuple</td><td><code>a = np.array((v1, v2, ...))</code></td></tr><tr><td>2+D array from lists</td><td><code>a = np.array([[v1, v2, ...], [w1, w2, ...]])</code></td></tr><tr><td>2+D array from tuples</td><td><code>a = np.array(((v1, v2, ...), (w1, w2, ...)))</code></td></tr><tr><td>array with all zero values</td><td><code>a = np.zeros((rows, cols), dtype=np.type)</code></td></tr><tr><td>array with all one values</td><td><code>a = np.ones((rows, cols), dtype=np.type)</code></td></tr><tr><td>array with all a specific value</td><td><code>a = np.full((rows, cols), value, dtype=np.type)</code></td></tr><tr><td>array with same shape as another<br>and all a specific value</td><td><code>a = np.full_like(other_array, v), value, dtype=np.type)</code> or<br><code>a = np.full(other_aray.shape, v, dtype=np.type)</code></td></tr><tr><td>array with uninitialized values</td><td><code>a = np.empty((rows, cols), dtype=np.type)</code><br>Values come from whatever happens to be at the memory location.</td></tr><tr><td>1D array with range of values</td><td><code>a = np.arange(start, end, step, dtype=np.type)</code><br>Values can be integer or float.<br><code>start</code> is inclusive and defaults to 0.<br><code>end</code> is exclusive and has no default.<br><code>step</code> defaults to 1.</td></tr><tr><td>1D array with evenly spaced values</td><td><code>a = np.linspace(start, end, count, dtype=np.type)</code><br><code>end</code> is inclusive.<br><code>count</code> is the number values to produce.</td></tr><tr><td>array with random float values</td><td><code>a = np.random.rand(rows, cols)</code><br>Values are between 0 (inclusive) and 1 (exclusive).</td></tr><tr><td>array with random integer values</td><td><code>a = np.random.randint(min, max, size=(rows, cols))</code><br><code>min</code> defaults to zero and is inclusive.<br><code>max</code> has no default and is exclusive.</td></tr><tr><td>identity matrix (creates n x n array)</td><td><code>a = np.identity(n, dtype=np.type)</code></td></tr><tr><td>copy of existing array</td><td><code>b = a.copy()</code></td></tr><tr><td>repeated copies elements in existing array</td><td><code>b = np.repeat(a, times, axis={0|1})</code><br>axis is 0 for vertical and 1 for horizontal.</td></tr></tbody></table><h2 id="getting-information-about-an-array">Getting Information About an Array</h2><table><thead><tr><th>Information</th><th>Attribute</th></tr></thead><tbody><tr><td>number of dimensions</td><td><code>a.dim</code></td></tr><tr><td>shape (size of each dimension)</td><td><code>a.shape</code></td></tr><tr><td>data type of elements</td><td><code>a.dtype</code></td></tr><tr><td>number of elements (product of dimension sizes)</td><td><code>a.size</code></td></tr><tr><td>size of each element in bytes</td><td><code>a.itemsize</code></td></tr><tr><td>total size (<code>a.size * a.itemsize</code>)</td><td><code>a.nbytes</code></td></tr></tbody></table><h2 id="element-access">Element Access</h2><p>In all function below that accept row and column indexes, any number of indexes can be specified, including one.</p><p>In the tables that follow, some abbreviations are used for arguments.</p><ul><li>Row index values below are abbreviated as <code>ri</code>.</li><li>Column index values below are abbreviated as <code>ci</code>.</li><li>Row start indexes (<code>rsi</code>) and column start indexes (<code>csi</code>) are inclusive and default to zero.</li><li>Row end indexes (<code>rei</code>) and column end indexes (<code>cei</code>) are exclusive and default to length.</li><li>Negative index values can be used to count from the end of a dimension where <code>-1</code> is the last element.</li></ul><table><thead><tr><th>Operation</th><th>Code</th></tr></thead><tbody><tr><td>get element value</td><td><code>a[ri, ci]</code></td></tr><tr><td>get entire row</td><td><code>a[ri, :]</code></td></tr><tr><td>get entire column</td><td><code>a[:, ci]</code></td></tr><tr><td>get specific columns from a row</td><td><code>a[ri, [ci1, ci2, ...]]</code></td></tr><tr><td>get range of columns from a row</td><td><code>a[ri, csi:cei:step]</code></td></tr><tr><td>set element value</td><td><code>a[ri, ci] = v</code></td></tr><tr><td>set all elements in a row to a value</td><td><code>a[ri, :] = v</code></td></tr><tr><td>set all elements in a column to a value</td><td><code>a[:, ci] = v</code></td></tr><tr><td>set all elements in a row to values</td><td><code>a[ri, :] = [v1, v2, ...]</code><br>must provide all values</td></tr><tr><td>set all elements in a column to values</td><td><code>a[:, ci] = [v1, v2, ...]</code><br>must provide all values</td></tr><tr><td>set range of elements in a row to values</td><td><code>a[ri, csi:cei] = [v1, v2, ...]</code></td></tr><tr><td>set range of elements in a column to values</td><td><code>a[rsi:rei, ci] = [v1, v2, ...]</code></td></tr></tbody></table><h2 id="operations-on-one-array">Operations on One Array</h2><p>NumPy supports hundreds of operations that produce new arrays from the elements in existing arrays.</p><p>Here is a sampling of some that create a new array from the elements of an existing array.</p><table><thead><tr><th>Operation</th><th>Code</th></tr></thead><tbody><tr><td>add and create new array</td><td><code>b = a + v</code></td></tr><tr><td>add in place</td><td><code>a += v</code></td></tr><tr><td>subtract</td><td><code>b = a - v</code></td></tr><tr><td>multiply</td><td><code>b = a \* v</code></td></tr><tr><td>divide</td><td><code>b = a / v</code></td></tr><tr><td>reciprocal</td><td><code>b = np.reciprocal(a)</code><br>works with floats, but not integers</td></tr><tr><td>exponentiation</td><td><code>b = a \*\* v</code></td></tr><tr><td>square</td><td><code>b = np.square(a)</code></td></tr><tr><td>square root</td><td><code>b = np.sqrt(a)</code></td></tr><tr><td>sine</td><td><code>b = np.sin(a)</code></td></tr><tr><td>cosine</td><td><code>b = np.cos(a)</code></td></tr><tr><td>tangent</td><td><code>b = np.tan(a)</code></td></tr><tr><td>absolute value</td><td><code>b = np.absolute(a)</code> or<br><code>b = np.fabs(a)</code></td></tr><tr><td>round to nearest integer</td><td><code>b = np.rint(a)</code></td></tr><tr><td>floor</td><td><code>b = np.floor(a)</code></td></tr><tr><td>ceiling</td><td><code>b = np.ceil(a)</code></td></tr><tr><td>truncate</td><td><code>b = np.trunc(a)</code></td></tr><tr><td>sign (-1, 0, or 1)</td><td><code>b = np.sign(a)</code></td></tr><tr><td>convert degrees to radians</td><td><code>b = np.radians(a)</code> or <code>b = np.deg2rad(a)</code></td></tr><tr><td>convert radians to degrees</td><td><code>b = np.degrees(a)</code> or <code>b = np.rad2deg(a)</code></td></tr></tbody></table><h2 id="operations-on-two-arrays">Operations on Two Arrays</h2><p>Here is a sampling of operations that combine corresponding elements of two arrays to create elements in a new array.</p><table><thead><tr><th>Operation</th><th>Code</th></tr></thead><tbody><tr><td>add elements</td><td><code>b = np.add(a1, a2)</code></td></tr><tr><td>subtract elements</td><td><code>b = np.subtract(a1, a2)</code></td></tr><tr><td>multiply elements</td><td><code>b = np.multiply(a1, a2)</code></td></tr><tr><td>divide elements</td><td><code>b = np.divide(a1, a2)</code></td></tr><tr><td>maximum</td><td><code>b = np.maximum(a1, a2)</code> or<br><code>b = np.fmax(a1, a2)</code><br>element-wise only for 1D arrays</td></tr><tr><td>minimum</td><td><code>b = np.minimum(a1, a2)</code> or<br><code>b = np.fmin(a1, a2)</code><br>element-wise only for 1D arrays</td></tr><tr><td>greatest common divisor</td><td><code>b = np.gcd(a1, a2)</code><br>can also pass two numbers</td></tr><tr><td>lowest common multiple</td><td><code>b = np.lcm(a1, a2)</code><br>can also pass two numbers</td></tr></tbody></table><p>Here is a sampling of other operations on two arrays.</p><table><thead><tr><th>Operation</th><th>Code</th></tr></thead><tbody><tr><td>matrix multiplication</td><td><code>b = np.matmul(a1, a2)</code><br>The number of columns in <code>a1</code> must<br>equal the number of rows in <code>a2</code>.</td></tr></tbody></table><p>More detail is coming soon!</p></article>